# 中前台前端综合解决方案

1. 基于 `vue3.2`，集合最新发布的 script setup 语法标准
2. 融合了几乎所有常见的`前台`、`中台`业务模型
3. 同时适配`移动端`和`PC端`
4. 总结出几十种对应的解决方案，几十种通用的中台组件
5. 时长`30h`

**项目功能介绍**

后台的项目`千篇一律`，前台的项目`花样百出`

**课程收获**

`大厂标准`的项目架构设计

数十种经典业务模型以及对应的解决方案

十几种中台组件的构建思路以及对应的解决方案

**适应人群**

在校学生

新入职场的开发者

有一定经验的开发者

## 2 全新的项目构建方案

### 2.2 `vite` vs `webpack`

1. **为什么快？**

   `webpack` 打包机制：在开发构建时，默认**会去抓取并构建你的整个应用，然后才能提供服务**，这就导致你的项目中，存在的任何一个错误（哪怕是用户从来都没有进入过的页面中出现的），他依然会影响到你的整个项目构建。**当你的项目越大时，构建的时间就会越长**。

   `vite`打包机制：**`vite`不会一开始就构建你的整个项目**，而是会将应用中的模块区分为**依赖**和**源码(项目代码)**两部分，对于部分，它会根据**路由来拆分**代码模块，只会去构建一开始就必须要构建的内容。同时`vite`以[原生ESM](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)的方式为浏览器提供源码，让浏览器接管了**打包**的部分工作。因为这样一个机制，无论你的项目有多大，他只会构建一开始必须要构建的内容，这就让`vite`在构建时的速度打打提升了。

2. **这种机制会存在问题吗？**

   如果项目中存在 `commonJS`的内容，就无法解析。例如`axios`早期版本就依赖`commonJS`规范。

3. **官方如何解决的这种问题？**

   通过[依赖预构建](https://cn.vitejs.dev/guide/dep-pre-bundling.html)，将`CommonJS`或`UMD`发布的依赖项转换为`ESM`，再重新进行编译。可以理解为**速度对业务的一个妥协**。

### 2.4  为什么选择`vite`

当前 `vit` 版本 2.8.5。已经足够支持**企业级开发**

### 2.5 通过`vite`构架《小慕前端》

`vite`版本2.8.0 、`node`16.13.1、 `npm`8.1.2

`vite`需要node版本>=12.0.0

```json
// package.json
"scripts": {
    "dev": "vite --host"
}
```

## 3 定制化、高可用前台样式处理方案

[**tailwindcss**](https://tailwindcss.com/)解决企业及项目下`css`痛点

每隔6个月，你要学习的前端技术就增加了一倍。

- 统一的变量维护困难

- 大量的ClassName负担
- HTML、CSS分离造成了滚动问题
- 响应式、主题切换实现复杂

### 3.3 安装tailwindcss到你的项目

```js
// tailwind.config.js
module.export = {
    // tailwind应用到那些文件
    content: ['./index.html', './src/**/*.{vue,js}'],
    theme: {
        extend: {}
    },
    plugins: []
}
```

创建src/style/index.scss文件，并写入代码：

```scss
// 导入 tailwind 的基础指令组件
@tailwind base;
@tailwind components;
@tailwind utilities;
```

然后在`src/main.js` 中引入该` index.scss` 。

```js
import './style/index.scss'
```

因为使用了`scss`，需要安装sass解析。执行  `npm i -D sass@1.45.0` 安装 sass

在`src/App.vue` 中为`img`标签增加一个 `class="bg-red-900"`，北京变红则表示成功。

### 3.4 tailwindcss初体验

**tailwind** 官方介绍为**无需离开HTML即可快速构建现代网络**。每一个类名背后都代表一个`css`属性

`tailwindcss`是一个非常富有争议的库，喜欢它的人和讨厌它的人都非常多。

### 3.5 tailwind设计理念和价值体现

1. **设计理念**

   - 原子化`css`：每一个类名所代表都是一个`css`属性（争议的核心）

     整个前端历史，`css`颗粒度设计主要分成4种形式（**颗粒度自上而下逐渐增大，颗粒度越大则约束性越高，可定制性越弱**）

     1. 行内样式：样式全部写入行内，自由度最高，可定制化最强，但是不方便样式的复用，每次都要写完整的样式。
     2. 原子化css：每一个类型都代表了一个css属性。自由度依然很强，可定制化依然很高，也方便复用。但是大量的样式会造成大量的类名。
     3. 传统形式：通过一个或几个具有语义化的 class 来描述一段css属性。封装性强，语义化强，自由度和可定制化性一般。但是大量的html需要大量的语义化class，并且在html和css中需要来回切换、查找。
     4. 组件形式：在组件库中极为常见。封装性极强（不光封装了样式，也封装了功能），语义化强。但是自由度和可定制化性比较差

2. **价值体现**

- **高定制化**

- **高个性化**

- **高交互性**

行内样式：无复用性，不适合！

组件样式：通用组件库，固定风格，不适合！

传统形式：响应式、主题替换等复杂功能实现复杂。

综上所述：原子化`CSS`，最合适

总结：

1. 如果想要实现一个**通用的后台项目**，那么推荐使用**通用组件库**实现。
2. 如果想要实现一个**高定制化、高个性化、高交互性**的前台项目，那么推荐使用`tailwindcs`实现

## 4 明星项目架构解决方案--搭建基础项目结构

### 4.2 项目开发助手Prettier - Code formatter、Tailwind CSS IntelliSense、volar

Prettier - Code formatter：代码格式管理

文件名：.prettierrc

```json
{
    "semi":false,  // 当前代码结尾不需要增加分号
    "singleQuote": true, // 使用单引号代替双引号
    "trailingComma": 'none', // 当前是否需药尾随逗号 
    
}
```

配置vue和js使用默认化：

鼠标右击，选择 **使用...格式化文档**，选择配置默认格式化程序 -> Prettier - Formatter

保存代码自动格式化：配置->**Editor:Format On Save** 勾选

Tailwind CSS IntelliSense：开发过程中类名提示

Volar：vue3推荐辅助工具

### 4.3 项目架构基本结构处理分析

响应式构建：一套代码实现移动端和PC端的显示。分析大的路由方案。然后分析某个模块的构建方案

移动端和PC端两者路由结构不一样。要展示的东西不一样。根据**当前用户所在设备不同，构建不同的路由表**，需要生成**多个路由表**来应对不同的情况。

### 4.4 构建项目架构

```json
| —— api // 接口请求
| —— assets // 静态资源文件
|    | —— icons // svg icon图标
|    | —— images // image图标， xxx.png
|    | —— logo.png // logo
| —— router // 路由
|    | —— index.js // 路由处理中心
|    | —— modules // 路由模块
|         | —— mobile-routes.js // 移动端路由
|         | —— pc-routes.js // PC段路由
| —— components // 通用的业务组件。比如：一个组件在多个页面中使用到
| —— constants // 常量
| —— directives // 自定义指令
| —— libs // 通用组件，可用于构建中台物料库或通用组件库
| —— main.js // 入口文件
| —— permission.js // 页面权限控制中心
| —— store // 全局状态
|    | —— getters.js // 全局状态访问处理
|    | —— index.js // 全局状态中心
|    | —— modules // 状态子模块
| —— style // 全局样式
|    | —— index.scss // 全局通用的样式处理
| —— util // 工具模块
| —— vendor // 外部供应资源，比如人类行为认证
| —— views // 页面组件，与components 的区别在于：此处组件对应路由表，以页面的形式展示
|    | —— layout // 用于PC端，分割一级路由和二级路由
|         | —— components // 该页面组件下的业务组件
|         | —— index.vue // layout组件
| —— tailwind.config.js // tailwind css 配置文件，与src平级
| —— vite.config.js // vite配置文件，与src平级
```

## 5 企业级vite配置方案

### 5.2 明确移动端和PC端的构建顺序

项目使用 `tailwindcss`。所以构建顺序需要尊重`tailwindcss`的构建顺序。

**移动优先**

使用tailwind构建响应式系统时，需要先构建移动端，再构建PC端

 ### 5.3 构建移动处理工具MobileTerminal

src/utils/flexble.js -> isMobileTerminal，结果不是响应式，需要切换刷新，有缺点，5.4优化

### 5.4 通过vueuse优化处理方案

[**vueuse中文网**](https://vueuse.nodejs.cn/) 方法响应式结果

```js
import { PC_DEVICE_WIDTH } from '@/constants'
// PC 设备指定宽度
// export const PC_DEVICE_WIDTH = 1280
import { useWindowSize } from '@vueuse/core'
const { width } = useWindowSize()
// 不用自动刷新也会计算
export const isMobileTerminal = computed(() => {
  return width.value < PC_DEVICE_WIDTH
})
```

### 5.5 定义@软链接

引用文件相对路./径改成@开头的软链接 **[resolve.alias](https://cn.vitejs.dev/config/shared-options.html#resolve-alias)**

```js
// vite.config.js
import path, { join } from 'path'

export default defineConfig({
  ...
  // 软链接
  resolve: {
    alias: {
      '@': join(__dirname, '/src')
    }
  },
  ...
})
```

### 5.6 构建VueRouter移动端路由表

router/index.js

```js
import { createRouter, createWebHistory } from 'vue-router'
import { isMobileTerminal } from '@/utils/flexible'
// 移动端路由表
import mobileTerminalRoutes from './modules/mobile-routes'
// pc断路由表
import pcTerminalRoutes from './modules/pc-routes'

// 创建 vueRouter 实例
const router = createRouter({
  // history 使用哪种模式 hash模式 #开头
  history: createWebHistory(),
  // routes 路由表，移动端还是pc断路由表 isMobileTerminal
  routes: isMobileTerminal.value ? mobileTerminalRoutes : pcTerminalRoutes
})

export default router

```

main.js中导入注册

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
...
createApp(App).use(router).mount('#app')

...
```

App.vue 中保留一个一级路由出口

```vue
<template>
  <!-- 一级路由出口 -->
   <router-view></router-view>
</template>

<script setup></script>

<style lang="scss" scoped></style>
```

### 5.7 划分移动端首页模块

### 5.8 导入并配置axios

安装：npm install --save axios@0.26.1

创建 src/utils.request.js

```js
import axios from 'axios'
import store from '@/store'
import { message as $message } from '@/libs'

const service = axios.create({
  baseURL: import.meta.env.VITE_BASE_API,
  timeout: 5000
})

// 请求拦截器
service.interceptors.request.use(
  (config) => {
    config.headers.icode = '你需要在这里填入你的 icode'
    if (store.getters.token) {
      // 如果token存在 注入token
      config.headers.Authorization = `Bearer ${store.getters.token}`
    }
    return config // 必须返回配置
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
service.interceptors.response.use(
  (response) => {
    const { success, message, data } = response.data
    //   要根据success的成功与否决定下面的操作
    if (success) {
      return data
    } else {
      $message('warn', message)
      // TODO：业务错误
      return Promise.reject(new Error(message))
    }
  },
  (error) => {
    // 处理 token 超时问题
    if (
      error.response &&
      error.response.data &&
      error.response.data.code === 401
    ) {
      // TODO: token超时
      store.dispatch('user/logout')
    }
    $message('error', error.response.data.message)
    // TODO: 提示错误消息
    return Promise.reject(error)
  }
)

export default service
```



### 5.9 vite 处理代理服务器

**[server.proxy](https://cn.vitejs.dev/config/server-options.html#server-proxy)**

```js
// vite.config.js
import path, { join } from 'path'

export default defineConfig({
  ...
 // 代理
  server: {
    proxy: {
      // 代理所有 /api 的请求，该求情将被代理到 target 中
      '/api': {
        // 代理请求之后的请求地址
        target: 'https://api.imooc-front.lgdsunday.club/',
        // 跨域
        changeOrigin: true
      }
    }
  }
})
```

### 5.10 vite处理环境变量

**[.env文件](https://cn.vitejs.dev/guide/env-and-mode.html#env-files)**

开发环境  .env.development

```bash
# 只在指定模式（development）下加载

# base api, 只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理
VITE_BASE_API = '/api'

```

生产环境 .env.production

```bash
# base api, 只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理
VITE_BASE_API = '/prod-api'

# 只有 VITE_SOME_KEY 会被暴露为 import.meta.env.VITE_SOME_KEY 提供给客户端源码，而 DB_PASSWORD 则不会。
# VITE_SOME_KEY=123
# DB_PASSWORD=foobar

# console.log(import.meta.env.VITE_SOME_KEY) // "123"
# console.log(import.meta.env.DB_PASSWORD) // undefined
```

utils/request.js

```js
...
const service = axios.create({
  baseURL: import.meta.env.VITE_BASE_API, // 修改此处
  timeout: 5000
})
...
```

**[anywhere](https://www.npmjs.com/package/anywhere)** ：随起随用的静态文件服务器

`npm install anywhere -g`

进入打包过后的dist文件夹下。`vscode`命令行敲 anywhere 开启服务。查看项目发布

## 6 构建自己的物料解决方案-构建物料库，实现前端设计

物料库即组件库。

### 6.5 动态rem基准+修正tailwind，完善移动端navigator

1、动态rem基准

utils/flexible.js

```js
/**
 * 初始化 rem 基准值，最大为 40px
 
 */
export const useREM = () => {
  // 定义最大的 fontSize
  const MAX_FONT_SIZE = 40

  // 监听 html 文档被解析完成的事件
  document.addEventListener('DOMContentLoaded', () => {
    // 获取 html 标签
    const html = document.querySelector('html')
    // 获取根元素 fontSize 标准，屏幕宽度 / 10。（以 Iphone 为例 Iphone 6 屏幕宽度为 375，则标准 fontSize 为 37.5）
    let fontSize = window.innerWidth / 10
    // 获取到的 fontSize 不允许超过我们定义的最大值
    fontSize = fontSize > MAX_FONT_SIZE ? MAX_FONT_SIZE : fontSize
    // 定义根元素（html）fontSize 的大小 （rem）
    html.style.fontSize = fontSize + 'px'
  })
}
```

main.js

```js
import { useREM } from './utils/flexible'

// 设置 rem
useREM()
```

2、修正 **[tailwind Font-Size](https://tailwindcss.com/docs/font-size)**

tailwind.config.js

```js
module.exports = {
	theme: {
		extend: {
			...
            fontSize: {
                // 第一个是font-size 第二个是line-height
        		xs: ['0.25rem', '0.35rem'],
       		 	sm: ['0.35rem', '0.45rem'],
        		base: ['0.42rem', '0.52rem'],
       		 	lg: ['0.55rem', '0.65rem'],
        		xl: ['0.65rem', '0.75rem']
     		}
            ...
		}
	}
}
```

### 6.7 基于vite的统一svg处理svg-icon

src/libs/svg-icon/index.vue

```vue
<template>
  <svg aria-hidden="true">
    <use :class="fillClass" :xlink:href="symbolId" :fill="color" />
  </svg>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  // 显示的 svg 图标名称（剔除 icon-）
  name: {
    type: String,
    required: true
  },
  // 直接指定 svg 图标的颜色
  color: {
    type: String
  },
  // 通过 tailwind 指定 svg 颜色的类名
  fillClass: {
    type: String
  }
})
// 真实显示的 svg 图标名（拼接 #icon-）
const symbolId = computed(() => `#icon-${props.name}`)
</script>

```

src/libs/index.js 注册插件

```js
import { defineAsyncComponent } from 'vue'
export { confirm } from './confirm'
export { message } from './message'

export default {
  install(app) {
    // 获取当前路径任意文件夹下的 index.vue 文件
    const components = import.meta.glob('./*/index.vue')
    // 遍历获取到的组件模块
    for (const [key, value] of Object.entries(components)) {
      // 拼接组件注册的 name
      const componentName = 'm-' + key.replace('./', '').split('/')[0]
      // 通过 defineAsyncComponent 异步导入指定路径下的组件
      app.component(componentName, defineAsyncComponent(value))
    }
  }
}

```

main.js中注册

```js
import mLibs from './libs'

createApp(App).use(mLibs).mount('#app')
```

tailwind 自定义样式

tailwind.config.js

```
module.exports = {
	theme: {
		extend: {
			...
            boxShadow: { // 阴影
        		'l-white': '-10px 0 10px white',
        		'l-zinc': '-10px 0 10px #18181b'
      		}
            ...
		}
	}
}
```

### 6.8 vite处理svg矢量图

```bash
npm install --save-dev vite-plugin-svg-icons@2.0.1
```

vite.config.js

```js
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'
import path, { join } from 'path'

export default defineConfig({
    ...
    plugins: [
    vue(),
    createSvgIconsPlugin({
      // 指定需要缓存的图标文件夹
      iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],
      // 指定symbolId格式
      symbolId: 'icon-[name]'
    })
  	],
    ...
})

```

在main.js中注册icon

```js
// 注册 svg-icons 导入的地址是固定的
import 'virtual:svg-icons-register'
```

### 6.9  移动端slider处理

**[element.getBoundingClientRect()](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)** 。该对象有6个属性：[top](https://so.csdn.net/so/search?q=top&spm=1001.2101.3001.7020),lef,right,bottom,width,height；

返回值：

```json
{
  bottom：430, //元素底部距离窗口顶部的距离 (等于 y + height)
  height:340, //元素的高度
  left:120, //元素左侧距离窗口左侧的距离
  right:460, //元素右侧距离窗口左侧的距离(等于 x + width)
  top:90, //元素顶部距离窗口的距离
  width:340, //元素的宽度
  x:120, //元素左上角相对于视口的横坐标
  y:90 //元素左上角相对于视口的纵坐标
}
```

### 6.12 通用组件：弹出窗口-popup实现

**[useScrollLock](https://vueuse.nodejs.cn/core/useScrollLock/)**、**[useVModel](https://vueuse.nodejs.cn/core/useVModel/#usage)**

teleport、transition动画

```js
import { useScrollLock } from '@vueuse/core'
import { useVModel } from '@vueuse/core'

// 通过 useVModel 获取到响应式数据 isOpen，当 isOpen 改变时，会自动触发 update:modelValue
const isOpen = useVModel(props)
// ------ 滚动锁定 ------
const isLocked = useScrollLock(document.body)
```

通过` import { useVModel } from '@vueuse/core' `优化组件间双向数据绑定功能。

### 6.14 vite通用组件自动化注册

**vite 提供的功能，进行通用组件的自动化注册**，需要使用到两个关键的知识点：

1. **[vite的Glob导入功能](https://cn.vitejs.dev/guide/features.html#glob-import)**：该功能可以帮助我们在 **文件系统中导入多个模块**
2. vue 的 defineAsyncComponent方法：该方法可以创建一个 **按需加载的异步组件**

基于以上两个方法，实现组件自动注册

在 src/libs/index.js 中：

```js
import { defineAsyncComponent } from 'vue'
export { confirm } from './confirm'
export { message } from './message'

export default {
  install(app) {
    // 获取当前路径任意文件夹下的 index.vue 文件
    const components = import.meta.glob('./*/index.vue')
    // 遍历获取到的组件模块
    for (const [key, value] of Object.entries(components)) {
      // 拼接组件注册的 name
      const componentName = 'm-' + key.replace('./', '').split('/')[0]
      // 通过 defineAsyncComponent 异步导入指定路径下的组件
      app.component(componentName, defineAsyncComponent(value))
    }
  }
}
```

总结：

1. 定义了两个通用组件。svg-icon、propup。
2. 修正了 rem 值，对于移动端的 rem 处理目前可以根据设备的不同来自动修正。
3. 基于 vite 的 svg 矢量图导入和自动组件注册。
4. 介绍了 vueuse 中更多的功能方法。

## 7. 企业级通用业务Header处理方案

### 7.2 处理PC端基础架构

动态计算PC端的高度，结合tailwindcss 配置

tailwind.config.js 

```js
module.exports = {
  ...
  theme: {
    extend: {
      height: {
        header: '72px',
        main: 'calc(100vh - 72px)'
      },
      ...
    }
  },

}

```

src/views/layout/index.vue

```vue
<template>
  <div class="h-screen">
    <!-- 需要在 tailwind 中定义 h-header、h-main 高度 -->
    <header-vue class="h-header"></header-vue>
    <div class="h-main">
      <main-vue></main-vue>
    </div>
    <floating-vue></floating-vue>
  </div>
</template>
```

### 7.3 PC端Header模块处理分析与简单实现

### 7.4 通用组件：search搜索框能力分析

功能分析：

1. 输入内容实现双向数据绑定
2. 鼠标移入与获取焦点时的动画
3. 一键清空文本功能
4. 搜索触发功能
5. 可控制，可填充的下拉展区
6. 监听到以下事件列表：
   1. clear：删除所有文本事件
   2. input：输入事件
   3. focus：获取焦点事件
   4. blur：失去焦点事件
   5. search：触发搜索（点击或回车）事件

### 7.7 通用组件：button按钮功能实现

1. 构建 type 风格可选项和 size 大小可选项
2. 通过 props 让开发者控制按钮
3. 区分 icon button 和 text button
4. 依据当前的数据，实现视图
5. 处理点击事件

src/libs/button/index.vue

```vue
<template>
  <button
    class="text-sm text-center rounded duration-150 flex justify-center items-center"
    :class="[
      typeEnum[type],
      sizeEnum[sizeKey].button,
      { 'active:scale-105': isActiveAnim }
    ]"
    @click.stop="onBtnClick"
  >
    <!-- 展示 loading -->
    <m-svg-icon
      v-if="loading"
      name="loading"
      class="w-2 h-2 animate-spin mr-1"
    ></m-svg-icon>
    <!-- icon 按钮 -->
    <m-svg-icon
      v-if="icon"
      :name="icon"
      class="m-auto"
      :class="sizeEnum[sizeKey].icon"
      :color="iconColor"
      :fillClass="iconClass"
    ></m-svg-icon>
    <!-- 文字按钮 -->
    <slot v-else />
  </button>
</template>

<script>
import { computed } from 'vue'

// type 可选项：表示按钮风格
const typeEnum = {
  primary:
    'text-white  bg-zinc-800 dark:bg-zinc-900  hover:bg-zinc-900 dark:hover:bg-zinc-700 active:bg-zinc-800 dark:active:bg-zinc-700',
  main: 'text-white  bg-main dark:bg-zinc-900  hover:bg-hover-main dark:hover:bg-zinc-700 active:bg-main dark:active:bg-zinc-700',
  info: 'text-zinc-800 dark:text-zinc-300  bg-zinc-200 dark:bg-zinc-700 hover:bg-zinc-300 dark:hover:bg-zinc-600 active:bg-zinc-200 dark:active:bg-zinc-700 '
}
// size 可选项：表示按钮大小。区分文字按钮和icon按钮
const sizeEnum = {
  default: {
    button: 'w-8 h-4 text-base',
    icon: ''
  },
  'icon-default': {
    button: 'w-4 h-4',
    icon: 'w-1.5 h-1.5'
  },
  small: {
    button: 'w-7 h-3 text-base',
    icon: ''
  },
  'icon-small': {
    button: 'w-3 h-3',
    icon: 'w-1.5 h-1.5'
  }
}

const EMITS_CLICK = 'click'
</script>
<script setup>
const props = defineProps({
  // icon 图标名字
  icon: {
    type: String
  },
  // icon 图标颜色
  iconColor: {
    type: String
  },
  // icon 图标类名（匹配 tailwind）
  iconClass: {
    type: String
  },
  // 按钮风格
  type: {
    type: String,
    default: 'main',
    validator(val) {
      // 获取所有的可选的按钮风格
      const keys = Object.keys(typeEnum)
      // 开发者指定风格是否在可选风格中
      const result = keys.includes(val)
      // 如果不在则给开发者提示
      if (!result) {
        throw new Error(`你的 type 必须是 ${keys.join('、')} 中的一个`)
      }
      // 返回校验结果
      return result
    }
  },
  // 大小风格
  size: {
    type: String,
    default: 'default',
    validator(val) {
      // 获取所有的可选的大小（注意剔除 icon 开头的元素，因为我们期望开发者输入 size="default"，但不期望开发者输入 size="icon-default"）
      const keys = Object.keys(sizeEnum).filter((key) => !key.includes('icon'))
      // 开发者指定大小是否在可选大小中
      const result = keys.includes(val)
      // 如果不在则给开发者提示
      if (!result) {
        throw new Error(`你的 size 必须是 ${keys.join('、')} 中的一个`)
      }
      // 返回校验结果
      return result
    }
  },
  // 按钮在点击时是否需要动画
  isActiveAnim: {
    type: Boolean,
    default: true
  },
  // 加载状态
  loading: {
    type: Boolean,
    default: false
  }
})

const emits = defineEmits([EMITS_CLICK])

// 处理大小的 key 值
const sizeKey = computed(() => {
  return props.icon ? 'icon-' + props.size : props.size
})

/**
 * 按钮点击事件处理
 */
const onBtnClick = () => {
  if (props.loading) {
    return
  }
  emits(EMITS_CLICK)
}
</script>

<style lang="scss" scoped></style>
```

### 7.10 通用组件：popover气泡卡片能力分析

### 7.15 通用组件：处理慢速移动时，气泡消失问题

因为在 `reference` 与气泡之间存在间隙，鼠标移动到间隙处就会消失。就会触发`mouseleave` 鼠标移出事件，此时`isVisiable` 就会变成`false`

想要解决这个问题，我们可以利用 **类似于防抖（`debounce`）**的概念。

也就是：鼠标刚离开时，不立刻修改`isVisiable`，而是延迟一段时间，如果在这段时间之内，再次触发了鼠标移入时间，则不再修改` isVisiable`

以此来解决慢速移动的问题。

```js
// 延迟关闭时长
const DELAY_TIME = 100

// 控制延迟关闭
let timeout = null
/**
 * 鼠标移入的触发行为
 */
const onMouseenter = () => {
  isVisable.value = true
  // 再次触发时，清理延时装置
  if (timeout) {
    clearTimeout(timeout)
  }
}
/**
 * 鼠标移出的触发行为
 */
const onMouseleave = () => {
  // 延时装置
  timeout = setTimeout(() => {
    isVisable.value = false
    timeout = null
  }, DELAY_TIME)
}
```

## 8. 企业级复杂前中台项目响应式处理方案

响应式（多指响应式布局：一套样式在多段展示）

### 8.2 响应式下 navigationBar 实现方案分析

通常情况下，复杂功能的响应式处理，我们一般有三种解决方案：

1. 一套代码处理多端：
   1. 优势：代码数量相对较少
   2. 劣势：耦合性强，不利于后期维护

2. 多套代码分别处理各端：
   1. 优势：逻辑清晰
   2. 劣势：可能会产生很多重复性的逻辑

3. 结合以上两种方案：抽离共用逻辑，封装私有逻辑：

   1. 优势：结合以上两种优势

   2. 劣势：需要对业务和逻辑足够清楚

功能由两部分组成：

1. 数据：双端数据是一样的，可以复用，通过 `vuex`来封装公有数据这一系列的 **获取、切换**行为。
2. 视图：展示视图逻辑相差大，为了综合维护，不同端单独封装私有部分，需要在各自组建单独处理。

### 8.4 PC端navigationBar私有视图处理

### 8.5 PC端navigationBar私有逻辑处理

### 8.6 分析navigationBar闪烁问题

手动刷新的时候，navigation会闪烁。

1. 先让 categorys 具备一个初始化数据。
2. 从服务端获取数据，替换初始化数据
3. 为了防止初始化数据太老，我们把每次获取到的新数据，都作为下一次的初始化数据。

### 8.7 处理navigationBar闪烁问题

**解决1和2**。保留部分常用的，不用留全部。

src/constants/index.js

```js
// 初始 category 数据
export const CATEGORY_NOMAR_DATA = [
  ALL_CATEGORY_ITEM,
  { id: 'web_app_icon', name: 'UI/UX' },
  { id: 'design', name: '平面' },
  { id: 'illustration', name: '插画/漫画' },
  { id: 'photography', name: '摄影' },
  { id: 'games', name: '游戏' },
  { id: 'anime', name: '动漫' },
  {
    id: 'industrial_design',
    name: '工业设计'
  },
  {
    id: 'industrial_design',
    name: '建筑设计'
  },
  {
    id: 'industrial_design',
    name: '人文艺术'
  },
  {
    id: 'industrial_design',
    name: '家居/家装'
  }
]
```

src/store/modules/category.js

```js
import { getCategory } from '@/api/category'
import { ALL_CATEGORY_ITEM, CATEGORY_NOMAR_DATA } from '@/constants'

export default {
  // 独立作用域
  namespaced: true,
  state: () => ({
    // navigationBar 展示的数据源
    categorys: CATEGORY_NOMAR_DATA
  }),
  mutations: {
    /**
     * 为 categorys 赋值的统一操作
     */
    setCategorys(state, categorys) {
      state.categorys = [ALL_CATEGORY_ITEM, ...categorys]
    }
  },
  actions: {
    /**
     * 将从接口获取得了数据的异步逻辑放到 store 的 actions 中
     * 获取 category 数据，并自动保存到 vuex 中
     */
    async useCategoryData(context) {
      const { categorys } = await getCategory()
      context.commit('setCategorys', categorys)
    }
  }
}

```

**解决3**：为了防止初始化数据太老，我们把每次获取到的新数据，都作为下一次的初始化数据。

**方案**：每次获取到的新数据，进行缓存。在下次运行时，把缓存的数据作为初始值

category数据缓存，覆盖初始数据。利用**[vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate#readme)**

src/router/index.js

```js
import createPersistedState from 'vuex-persistedstate'

const store = createStore({
  getters,
  modules: {
    category,
    theme,
    app,
    search,
    user
  },
  plugins: [
      // 数据缓存
    createPersistedState({
      // 保存到 localStorage 中的 key
      key: 'imooc-front',
      // 需要保存的模块，只有被放入的模块才会自动执行被缓存
      paths: ['category', 'theme', 'search', 'user']
    })
  ]
})

export default store
```

## 9. 主题替换解决方案

基于tailwind的主题替换

### 9.1 主题替换原理分析

原理：通过类名来控制对应的样式（主题），当类名发生改变时，即完成了主题替换。

### 9.3 tailwindDarkMode原理

利用 **[DarkMode](https://tailwindcss.com/docs/dark-mode)** 实现主题替换

1. 给对应的组件DOM添加`dark css`样式
2. 给 `html` 跟标签增加class=“dark"的样式

tailwind.config.js 配置

```js
module.exports = {
  // 手动切换暗模式
  darkMode: 'class',
  ...
}
```

### 9.4 为组件增加dark适配

### 9.5 DarkMode在复杂应用中的实现逻辑分析

**处理流程：**

1. 监听主题的切换行为 

   src/constants/index.js

   ```js
   // 暗黑主题
   export const THEME_DARK = 'dark'
   // 浅色主题
   export const THEME_LIGHT = 'light'
   // 系统主题
   export const THEME_SYSTEM = 'system'
   ```

   src/store/modules/theme.js

   ```js
   import { THEME_LIGHT } from '@/constants'
   export default {
     namespaced: true,
     state: () => ({
       // 主题模式
       themeType: THEME_LIGHT
     }),
     mutations: {
       /**
        *  切换主题模式
        */
       changeThemeType(state, newTheme) {
         state.themeType = newTheme
       }
     }
   }
   ```

   

2. 将当前切换主题保存到 `vuex `中

   src/views/layout/components/header/header-theme.vue

   ```js
   import { THEME_DARK, THEME_LIGHT, THEME_SYSTEM } from '@/constants'
   import { useStore } from 'vuex'
   // 构建渲染数据源
   const themeArr = [
     {
       id: '0',
       type: THEME_LIGHT,
       icon: 'theme-light',
       name: '极简白'
     },
     {
       id: '1',
       type: THEME_DARK,
       icon: 'theme-dark',
       name: '极夜黑'
     },
     {
       id: '2',
       type: THEME_SYSTEM,
       icon: 'theme-system',
       name: '跟随系统'
     }
   ]
   const store = useStore()
   /**
    * menu 切换事件
    * @param {*} theme
    */
   const onItemClick = (theme) => {
     store.commit('theme/changeThemeType', theme.type)
   }
   ```

   

3. 根据 `vuex`中保存的当前主题，展示 header-theme下的显示图标

   src/views/layout/components/header/header-theme.vue

   ```js
   import { useStore } from 'vuex'
   import { computed } from 'vue'
   
   // 构建渲染数据源
   const themeArr = [
     {
       id: '0',
       type: THEME_LIGHT,
       icon: 'theme-light',
       name: '极简白'
     },
     {
       id: '1',
       type: THEME_DARK,
       icon: 'theme-dark',
       name: '极夜黑'
     },
     {
       id: '2',
       type: THEME_SYSTEM,
       icon: 'theme-system',
       name: '跟随系统'
     }
   ]
   
   // 控制图标展示
   const store = useStore()
   const svgIconName = computed(() => {
     // 根据当前的 themeType 返回当前的选中 icon
     const findTheme = themeArr.find((theme) => {
       return theme.type === store.getters.themeType
     })
     return findTheme?.icon || themeArr[0].type
   })
   ```

4. 根据 `vuex`中保存的当前主题，修改 `html` 的 class

   src/utils/theme.js

   ```js
   import store from '@/store'
   import { watch } from 'vue'
   import { THEME_LIGHT, THEME_DARK, THEME_SYSTEM } from '@/constants'
   
   /**
    * 监听系统主题变更
    */
   let matchMedia
   const watchSystemThemeChange = () => {
     // 仅需初始化一次即可
     if (matchMedia) return
     matchMedia = window.matchMedia('(prefers-color-scheme: dark)')
     // 监听主题变更
     matchMedia.onchange = function () {
       changeTheme(THEME_SYSTEM)
     }
   }
   
   /**
    * 变更主题
    * @param {*} theme 主题的标记常量
    */
   const changeTheme = (theme) => {
     // html 的 class
     let themeClassName = ''
     switch (theme) {
       case THEME_LIGHT:
         themeClassName = 'light'
         break
       case THEME_DARK:
         themeClassName = 'dark'
         break
       case THEME_SYSTEM:
         watchSystemThemeChange()
         themeClassName = matchMedia.matches ? 'dark' : 'light'
         break
     }
     // 修改 html 的 class
     document.querySelector('html').className = themeClassName
   }
   
   /**
    * 初始化主题
    */
   export default () => {
     watch(() => store.getters.themeType, changeTheme, {
       // 初始执行一次
       immediate: true
     })
   }
   
   ```

   main.js

   ```js
   ...
   import useTheme from './utils/theme'
   ...
   
   // 设置 rem
   useREM()
   // 初始化主题
   useTheme()
   createApp(App).use(router).use(store).use(mLibs).use(mDirective).mount('#app')
   ```

### 9.7 跟随系统的主题变更

跟随系统的主体变更

想要生成跟随系统主题变更，那么我们就需要 **监听系统的主题变化**

想要做到这一点，可以利用 **[Window.matchMedia()](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)**方法，该方法接受一个 `**mediaQueryString**` （媒介查询解析的字符串）

该字符串可以传递 **[prefers-color-schema](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme)** 

1. 该对象存在一个 **[change](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/change_event)** 事件，可以监听 主体发生变更 的行为。
2. 同时存在一个 **[matches](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/matches)** 属性， 该属性为 boolean 的值：
   1. true：深色主题
   2. false：浅色主题

src/utils/theme.js

```js
/**
 * 监听系统主题变更
 */
let matchMedia
const watchSystemThemeChange = () => {
  // 仅需初始化一次即可
  if (matchMedia) return
  matchMedia = window.matchMedia('(prefers-color-scheme: dark)')
  // 监听主题变更
  matchMedia.onchange = function () {
    changeTheme(THEME_SYSTEM)
  }
}
```

总结：主题替换的功能

1. 主题替换原理
2. tailwind 主题替换原理
3. 复杂应用中的实现方案
4. 跟随系统的主题变更

目前市面上很多的 **组件库** 也都包含了主题替换的功能，原理和本章讲的差不多。

## 10.瀑布流+长列表+懒加载处理方案

### 10.3 通用组件:瀑布流组件构建分析

列表展示展示：**瀑布流组件的构建过程**

**存在的问题**就是：**每个 item 应该横向排列，第二行的 item 顺序连接到当前最短的列中**，而这个也是构建瀑布流的核心逻辑。

要实现核心逻辑，**我们的每个 `item` 肯定就不可以使用正常的布局方式，而必须使用 `absolute` 绝对布局，通过`top`，` left `来手动控制位置**。

构建**瀑布流组件**分为几部分：

1. 通过 props 传递关键数据（部分）：
   1. data：数据源
   2. `nodeKey`：唯一标识
   3. column：渲染的列数
   4. `picturePreReadin`：是否需要图片预渲染
2. 瀑布流渲染机制：通过 `absolute` 配合 `relativ` 完成布局，布局逻辑为：**每个 item 应该横向排列，第二行的item顺序连接到当前最短的列中**
3. 通过 **作用域插槽** 将每个 item 中设计到的关键数据，传递到 item 视图中。

### 9.4 通用组件-瀑布流：构建瀑布流布局，获取容器宽度与列宽

`src/ibs/waterfall/index.vue` 核心逻辑

### 10.6 瀑布流：区分图片预加载，获取圆度关键属性

想要计算每列的 left，right，那么需要拿到每个 item 的高度，因为只有有了每一个 item 高，才可以判断下一列的第一个item 的位置。

同时根据`picturePreReading`又可以分为两种情况：

1. 需要图片预加载时，图片高度未知
2. 不需要图片预加载时，图片高度已知

根据以上分析可得出以下结论：

根据两种不同的情况，我们需要有两个不同的方法来计算

**图片预加载时**

1. 图片高度未知：

   ```js
   // item 高度集合
   let itemHeights = []
   /**
    * 监听图片加载完成
    */
   const waitImgComplate = () => {
     itemHeights = []
     // 拿到所有元素
     let itemElements = [...document.getElementsByClassName('m-waterfall-item')]
     // 获取所有元素的 img 标签
     const imgElements = getImgElements(itemElements)
     // 获取所有 img 标签的图片
     const allImgs = getAllImg(imgElements)
     onComplateImgs(allImgs).then(() => {
       // 图片加载完成，获取高度
       itemElements.forEach((el) => {
         itemHeights.push(el.offsetHeight)
       })
       // 渲染位置
       useItemLocation()
     })
   }
   ```

2. 以上使用到了多个工具方法，src/libs/waterfall/utils.js 模块进行处理

   ```js
   /**
    * 从 itemElement 中抽离出所有的 imgElements
    */
   export const getImgElements = (itemElements) => {
     const imgElements = []
     itemElements.forEach((el) => {
       imgElements.push(...el.getElementsByTagName('img'))
     })
     return imgElements
   }
   
   /**
    * 生成所有的图片链接数组
    */
   export const getAllImg = (imgElements) => {
     return imgElements.map((imgElement) => {
       return imgElement.src
     })
   }
   
   /**
    * 监听图片数组加载完成（通过 promise 完成）
    */
   export const onComplateImgs = (imgs) => {
     // promise 集合
     const promiseAll = []
     // 循环构建 promiseAll
     imgs.forEach((img, index) => {
       promiseAll[index] = new Promise((resolve, reject) => {
         const imageObj = new Image()
         imageObj.src = img
         imageObj.onload = () => {
           resolve({
             img,
             index
           })
         }
       })
     })
     return Promise.all(promiseAll)
   }
   
   /**
    * 返回列高对象中的最小高度所在的列
    */
   export const getMinHeightColumn = (columnHeightObj) => {
     const minHeight = getMinHeight(columnHeightObj)
     return Object.keys(columnHeightObj).find((key) => {
       return columnHeightObj[key] === minHeight
     })
   }
   
   /**
    * 返回列高对象中的最小的高度
    */
   export const getMinHeight = (columnHeightObj) => {
     const columnHeightArr = Object.values(columnHeightObj)
     return Math.min(...columnHeightArr)
   }
   
   /**
    * 返回列高对象中的最大的高度
    */
   export const getMaxHeight = (columnHeightObj) => {
     const columnHeightArr = Object.values(columnHeightObj)
     return Math.max(...columnHeightArr)
   }
   ```

**不需要图片预加载时**

1. 图片高度已知（接口自带）

   ```js
   /**
    * 图片不需要预加载时，计算 item 高度
    */
   const useItemHeight = () => {
     itemHeights = []
     // 拿到所有元素
     let itemElements = [...document.getElementsByClassName('m-waterfall-item')]
     // 计算 item 高度
     itemElements.forEach((el) => {
       // 依据传入数据计算出的 img 高度
       itemHeights.push(el.offsetHeight)
     })
     // 渲染位置
     useItemLocation()
   }
   ```

**渲染位置**

在 `useItemLocation` 方法中，打印所有的图片高度

```js
/**
 * 为每个 item 生成位置属性
 */
const useItemLocation = () => {
  // 遍历数据源
  props.data.forEach((item, index) => {
    // 避免重复计算
    if (item._style) {
      return
    }
    // 生成 _style 属性
    item._style = {}
    // left
    item._style.left = getItemLeft()
    // top
    item._style.top = getItemTop()
    // 指定列高度自增
    increasingHeight(index)
  })

  // 指定容器高度
  containerHeight.value = getMaxHeight(columnHeightObj.value)
}
```

### 10.10 通用组件-瀑布流：总结

瀑布流是一个比较复杂的通用组件，因为我们要尽量做到 **普适**，所以就需要考虑到各种场景下的处理方案，尽量可以满足日常开发的场景。所以这就在原本就复杂的前提下，让这个功能变得更加复杂了。

下面我们就再来梳理一下整个瀑布流的构建过程:

1. 瀑布流的核心就是:**通过 relative 和 absolute 定位的方式，来控制每个 item 的位置**
2. 影响瀑布流高度的主要元素，通常都是 **`img`** 标签
3. 有些服务端会返回 关键  **`img`**  的高度，有些不会，所以我们需要分别处理:
   1. 当服务端 **不返回** 高度时:我们需要等待 **`img`** 加载完成之后，再来计算高度，然后通过得到的高度计算定位。否则则会出现高度计算不准确导致定位计算不准确的问题。
   2. 当服务端 **返回** 高度时:开发者则必须利用此高度为 item 进行高度设定。一旦 item 具备指定高度，那么我们就不需要等待 **`img`** 加载的过程，这样效率更高，并且可以业务的逻辑会变得更加简单

4. 当进行响应式切换时，同样需要区分对应场景:
   1. 当服务端 **不返回** 高度时:我们需要 **重新执行整个渲染流程**，虽然会耗费一些性能，但是这样可以最大可能的避-免出现逻辑错误。让组件拥有**更强的普适性。**
   2. 当服务端 **返回** 高度时:我们同样需要重新计算 **列宽** 和 **定位**，但是因为 item 具备明确的高度，所以我们可以直接拿到具体的高度，而无需重复整个渲染流程，从而可以实现更多的交互逻辑。比如:位移动画、将来的图片懒加载占位.

### 10.11 通用组件：长列表infinite构建分析

**1. 长列表的实现原理**

所谓长列表分页加载，其实就是指：**当滚动到列表底部，加载数据**

想要实现这个功能，要做的核心一点就是能够**监听到列表滚动到底部**，可以利用 [**IntersectionObserver**](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver) ,该接口可以判断：**目标元素与其祖先元素或顶级文档视窗`viewport`的交叉状态（是否可见）**

利用这个特性，**把一个元素置于列表底部**，当这个元素可见时，则表示**列表滚动到了底部**

那么原生的 `IntersectionOberver` 使用起来比较复杂，所以 `**vueuse**` 提供了 [**useIntersectionObserver**](https://vueuse.nodejs.cn/core/useIntersectionObserver/#useintersectionobserver) 方法

**2.我们使用长列表时，希望如何进行使用**

```vue
<m-infinite-list
     v-model="" // 当前是否处于加载状态
     :isFinished="" // 数据是否全部加载完成
     @onLoad="" // 加载下一页数据的触发事件
>
</m-infinite-list>
```

### 10.15 通用组件：解决首次数据无法铺满全屏时，数据无法继续加载

当首次加载的数据无法铺满全屏时，我们的数据无法继续加载。

原因：只触发了一次 `isIntersecting`

```js
// 处理 loading 状态
const loading = useVModel(props)

// 滚动的元素
const laodingTarget = ref(null)
// 记录当前是否在底部（是否交叉）
const targetIsIntersecting = ref(false)
useIntersectionObserver(
  laodingTarget,
  ([{ isIntersecting }], observerElement) => {
    // 获取当前交叉状态
    // 当加载更多的视图可见时，处理加载更多的逻辑
    targetIsIntersecting.value = isIntersecting
    // 触发 load
    emitLoad()
  }
)

/**
 * 触发 load
 */
const emitLoad = () => {
  // 当加载更多的视图可见时，加载更多数据，同时loading 为 false ，同时数据尚未全部加载完
  if (targetIsIntersecting.value && !loading.value && !props.isFinished) {
    // 修改加载数据标记
    loading.value = true
    // 触发加载更多行为
    emits('onLoad')
  }
}

/**
 * 监听 loading 的变化，解决数据加载完成后，首屏未铺满的问题，有点点性能问题，可以延迟执行，让其修改状态
 */
watch(loading, (val) => {
  // 触发 load，延迟处理，等待 渲染和 useIntersectionObserver 的再次触发
  setTimeout(() => {
    emitLoad()
  }, 100)
})
```

### 10.16 图片懒加载构建原因+实现原理

当 `query.size` 修改为100， 看到一次请求家在很多图片。请求次数有500多次

但是首屏看不到400多张图片，多余的请求就变得很浪费了。

用**图片懒加载实现功**能：减少多余的浪费请求

图片懒加载原理：**当图片不可见时，不加载图片，当图片可见时，采取加载图片。**

**可见**和**不可见**就是实现**长列表**时用过的套路

**监听所有图片是否可见，如果图片处于不可见状态，那么就不加载图片，如果图片处于可见状态，那么开始加载图片。**

这个功能的实现关键就是 **`IntersectionObserver`**

### 10.17 通用指令：实现图片懒加载

src/directives/modules/lazy.js

```js
import { useIntersectionObserver } from '@vueuse/core'

export default {
  // 图片懒加载：在用户无法看到图片时，不加载图片，在用户可以看到图片后加载图片
  // 如何判断用户是否看到了图片：useIntersectionObserver
  // 如何做到不加载图片（网络）：img 标签渲染图片，指的是 img 的 src 属性，src 属性是网络地址时，则会从网络中获取该图片资源。那么如果 img 标签不是网络地址呢？把该网络地址默认替换为非网络地址，然后当用户可见时，在替换成网络地址。
  mounted(el) {
    // 1. 拿到当前 img 标签的 src
    const imgSrc = el.src
    // 2. 把 img 标签的 src 替换为本地地址,图片都会消失，或者占位图片都可以
    el.src = ''

    // 3. 当图片区域可见，显示图片
    const { stop } = useIntersectionObserver(el, ([{ isIntersecting }]) => {
      if (isIntersecting) {
        el.src = imgSrc
        // 4. 加载完以后停止监听
        stop()
      }
    })
  }
}
```

### 10.18 深入`vite`：指令的自动注册

如果指令过得多，那么需要一个一个注册未免过于麻烦了，所以最好有一种方式 **指令的自动注册**

利用Glob导入（[`import.meta.globEager`）](https://cn.vitejs.dev/guide/features.html#glob-import) 和 [`Object.entrues`](https://web.nodejs.cn/en-us/docs/web/javascript/reference/global_objects/object/entries/) 功能

```js
/**
 * 全局指令注册
 */
export default {
  async install(app) {
    // https://cn.vitejs.dev/guide/features.html#glob-import
    // import.meta.globEager 为同步导入
    const directives = import.meta.globEager('./modules/*.js')
    for (const [key, value] of Object.entries(directives)) {
      // 拼接组件注册的 name
      const arr = key.split('/')
      const directiveName = arr[arr.length - 1].replace('.js', '')
      // 完成注册
      app.directive(directiveName, value.default)
    }
  }
}
```

### 10.19 指定彩色占位图

图片没有加载出来的时候，给出各种各样颜色点的占位符

src/utils/color.js

```js
/**
 * 生成随机色值
 */
export const randomRGB = () => {
  const r = Math.floor(Math.random() * 255)
  const g = Math.floor(Math.random() * 255)
  const b = Math.floor(Math.random() * 255)
  return `rgb(${r}, ${g}, ${b})`
}

```

src/views/main/components/list/item.vue

```vue
<template>
...
	<div
      class="relative w-full rounded cursor-zoom-in group"
      :style="{
        backgroundColor: randomRGB()
      }"
      @click="onToPinsClick"
    >
 ...
</template>

<script setup>
    ...
import { randomRGB } from '@/utils/color'
    ...
</script>
```



























