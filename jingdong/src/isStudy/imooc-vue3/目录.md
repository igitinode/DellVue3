# 中前台前端综合解决方案

1. 基于 `vue3.2`，集合最新发布的 script setup 语法标准
2. 融合了几乎所有常见的`前台`、`中台`业务模型
3. 同时适配`移动端`和`PC端`
4. 总结出几十种对应的解决方案，几十种通用的中台组件
5. 时长`30h`

**项目功能介绍**

后台的项目`千篇一律`，前台的项目`花样百出`

**课程收获**

`大厂标准`的项目架构设计

数十种经典业务模型以及对应的解决方案

十几种中台组件的构建思路以及对应的解决方案

**适应人群**

在校学生

新入职场的开发者

有一定经验的开发者

## 2 全新的项目构建方案

### 2.2 `vite` vs `webpack`

1. **为什么快？**

   `webpack` 打包机制：在开发构建时，默认**会去抓取并构建你的整个应用，然后才能提供服务**，这就导致你的项目中，存在的任何一个错误（哪怕是用户从来都没有进入过的页面中出现的），他依然会影响到你的整个项目构建。**当你的项目越大时，构建的时间就会越长**。

   `vite`打包机制：**`vite`不会一开始就构建你的整个项目**，而是会将应用中的模块区分为**依赖**和**源码(项目代码)**两部分，对于部分，它会根据**路由来拆分**代码模块，只会去构建一开始就必须要构建的内容。同时`vite`以[原生ESM](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)的方式为浏览器提供源码，让浏览器接管了**打包**的部分工作。因为这样一个机制，无论你的项目有多大，他只会构建一开始必须要构建的内容，这就让`vite`在构建时的速度打打提升了。

2. **这种机制会存在问题吗？**

   如果项目中存在 `commonJS`的内容，就无法解析。例如`axios`早期版本就依赖`commonJS`规范。

3. **官方如何解决的这种问题？**

   通过[依赖预构建](https://cn.vitejs.dev/guide/dep-pre-bundling.html)，将`CommonJS`或`UMD`发布的依赖项转换为`ESM`，再重新进行编译。可以理解为**速度对业务的一个妥协**。

### 2.4  为什么选择`vite`

当前 `vit` 版本 2.8.5。已经足够支持**企业级开发**

### 2.5 通过`vite`构架《小慕前端》

`vite`版本2.8.0 、`node`16.13.1、 `npm`8.1.2

`vite`需要node版本>=12.0.0

```json
// package.json
"scripts": {
    "dev": "vite --host"
}
```

## 3 定制化、高可用前台样式处理方案

[**tailwindcss**](https://tailwindcss.com/)解决企业及项目下`css`痛点

每隔6个月，你要学习的前端技术就增加了一倍。

- 统一的变量维护困难

- 大量的ClassName负担
- HTML、CSS分离造成了滚动问题
- 响应式、主题切换实现复杂

### 3.3 安装tailwindcss到你的项目

```js
// tailwind.config.js
module.export = {
    // tailwind应用到那些文件
    content: ['./index.html', './src/**/*.{vue,js}'],
    theme: {
        extend: {}
    },
    plugins: []
}
```

创建src/style/index.scss文件，并写入代码：

```scss
// 导入 tailwind 的基础指令组件
@tailwind base;
@tailwind components;
@tailwind utilities;
```

然后在`src/main.js` 中引入该` index.scss` 。

```js
import './style/index.scss'
```

因为使用了`scss`，需要安装sass解析。执行  `npm i -D sass@1.45.0` 安装 sass

在`src/App.vue` 中为`img`标签增加一个 `class="bg-red-900"`，北京变红则表示成功。

### 3.4 tailwindcss初体验

**tailwind** 官方介绍为**无需离开HTML即可快速构建现代网络**。每一个类名背后都代表一个`css`属性

`tailwindcss`是一个非常富有争议的库，喜欢它的人和讨厌它的人都非常多。

### 3.5 tailwind设计理念和价值体现

1. **设计理念**

   - 原子化`css`：每一个类名所代表都是一个`css`属性（争议的核心）

     整个前端历史，`css`颗粒度设计主要分成4种形式（**颗粒度自上而下逐渐增大，颗粒度越大则约束性越高，可定制性越弱**）

     1. 行内样式：样式全部写入行内，自由度最高，可定制化最强，但是不方便样式的复用，每次都要写完整的样式。
     2. 原子化css：每一个类型都代表了一个css属性。自由度依然很强，可定制化依然很高，也方便复用。但是大量的样式会造成大量的类名。
     3. 传统形式：通过一个或几个具有语义化的 class 来描述一段css属性。封装性强，语义化强，自由度和可定制化性一般。但是大量的html需要大量的语义化class，并且在html和css中需要来回切换、查找。
     4. 组件形式：在组件库中极为常见。封装性极强（不光封装了样式，也封装了功能），语义化强。但是自由度和可定制化性比较差

2. **价值体现**

- **高定制化**

- **高个性化**

- **高交互性**

行内样式：无复用性，不适合！

组件样式：通用组件库，固定风格，不适合！

传统形式：响应式、主题替换等复杂功能实现复杂。

综上所述：原子化`CSS`，最合适

总结：

1. 如果想要实现一个**通用的后台项目**，那么推荐使用**通用组件库**实现。
2. 如果想要实现一个**高定制化、高个性化、高交互性**的前台项目，那么推荐使用`tailwindcs`实现

## 4 明星项目架构解决方案--搭建基础项目结构

### 4.2 项目开发助手Prettier - Code formatter、Tailwind CSS IntelliSense、volar

Prettier - Code formatter：代码格式管理

文件名：.prettierrc

```json
{
    "semi":false,  // 当前代码结尾不需要增加分号
    "singleQuote": true, // 使用单引号代替双引号
    "trailingComma": 'none', // 当前是否需药尾随逗号 
    
}
```

配置vue和js使用默认化：

鼠标右击，选择 **使用...格式化文档**，选择配置默认格式化程序 -> Prettier - Formatter

保存代码自动格式化：配置->**Editor:Format On Save** 勾选

Tailwind CSS IntelliSense：开发过程中类名提示

Volar：vue3推荐辅助工具

### 4.3 项目架构基本结构处理分析

响应式构建：一套代码实现移动端和PC端的显示。分析大的路由方案。然后分析某个模块的构建方案

移动端和PC端两者路由结构不一样。要展示的东西不一样。根据**当前用户所在设备不同，构建不同的路由表**，需要生成**多个路由表**来应对不同的情况。

### 4.4 构建项目架构

```json
| —— api // 接口请求
| —— assets // 静态资源文件
|    | —— icons // svg icon图标
|    | —— images // image图标， xxx.png
|    | —— logo.png // logo
| —— router // 路由
|    | —— index.js // 路由处理中心
|    | —— modules // 路由模块
|         | —— mobile-routes.js // 移动端路由
|         | —— pc-routes.js // PC段路由
| —— components // 通用的业务组件。比如：一个组件在多个页面中使用到
| —— constants // 常量
| —— directives // 自定义指令
| —— libs // 通用组件，可用于构建中台物料库或通用组件库
| —— main.js // 入口文件
| —— permission.js // 页面权限控制中心
| —— store // 全局状态
|    | —— getters.js // 全局状态访问处理
|    | —— index.js // 全局状态中心
|    | —— modules // 状态子模块
| —— style // 全局样式
|    | —— index.scss // 全局通用的样式处理
| —— util // 工具模块
| —— vendor // 外部供应资源，比如人类行为认证
| —— views // 页面组件，与components 的区别在于：此处组件对应路由表，以页面的形式展示
|    | —— layout // 用于PC端，分割一级路由和二级路由
|         | —— components // 该页面组件下的业务组件
|         | —— index.vue // layout组件
| —— tailwind.config.js // tailwind css 配置文件，与src平级
| —— vite.config.js // vite配置文件，与src平级
```



 