# 中前台前端综合解决方案

1. 基于 `vue3.2`，集合最新发布的 script setup 语法标准
2. 融合了几乎所有常见的`前台`、`中台`业务模型
3. 同时适配`移动端`和`PC端`
4. 总结出几十种对应的解决方案，几十种通用的中台组件
5. 时长`30h`

**项目功能介绍**

后台的项目`千篇一律`，前台的项目`花样百出`

**课程收获**

`大厂标准`的项目架构设计

数十种经典业务模型以及对应的解决方案

十几种中台组件的构建思路以及对应的解决方案

**适应人群**

在校学生

新入职场的开发者

有一定经验的开发者

## 2 全新的项目构建方案

### 2.2 `vite` vs `webpack`

1. **为什么快？**

   `webpack` 打包机制：在开发构建时，默认**会去抓取并构建你的整个应用，然后才能提供服务**，这就导致你的项目中，存在的任何一个错误（哪怕是用户从来都没有进入过的页面中出现的），他依然会影响到你的整个项目构建。**当你的项目越大时，构建的时间就会越长**。

   `vite`打包机制：**`vite`不会一开始就构建你的整个项目**，而是会将应用中的模块区分为**依赖**和**源码(项目代码)**两部分，对于部分，它会根据**路由来拆分**代码模块，只会去构建一开始就必须要构建的内容。同时`vite`以[原生ESM](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)的方式为浏览器提供源码，让浏览器接管了**打包**的部分工作。因为这样一个机制，无论你的项目有多大，他只会构建一开始必须要构建的内容，这就让`vite`在构建时的速度打打提升了。

2. **这种机制会存在问题吗？**

   如果项目中存在 `commonJS`的内容，就无法解析。例如`axios`早期版本就依赖`commonJS`规范。

3. **官方如何解决的这种问题？**

   通过[依赖预构建](https://cn.vitejs.dev/guide/dep-pre-bundling.html)，将`CommonJS`或`UMD`发布的依赖项转换为`ESM`，再重新进行编译。可以理解为**速度对业务的一个妥协**。

### 2.4  为什么选择`vite`

当前 `vit` 版本 2.8.5。已经足够支持**企业级开发**

### 2.5 通过`vite`构架《小慕前端》

`vite`版本2.8.0 、`node`16.13.1、 `npm`8.1.2

`vite`需要node版本>=12.0.0

```json
// package.json
"scripts": {
    "dev": "vite --host"
}
```

## 3 定制化、高可用前台样式处理方案

[**tailwindcss**](https://tailwindcss.com/)解决企业及项目下`css`痛点

每隔6个月，你要学习的前端技术就增加了一倍。

- 统一的变量维护困难

- 大量的ClassName负担
- HTML、CSS分离造成了滚动问题
- 响应式、主题切换实现复杂

### 3.3 安装tailwindcss到你的项目

```js
// tailwind.config.js
module.export = {
    // tailwind应用到那些文件
    content: ['./index.html', './src/**/*.{vue,js}'],
    theme: {
        extend: {}
    },
    plugins: []
}
```

创建src/style/index.scss文件，并写入代码：

```scss
// 导入 tailwind 的基础指令组件
@tailwind base;
@tailwind components;
@tailwind utilities;
```

然后在`src/main.js` 中引入该` index.scss` 。

```js
import './style/index.scss'
```

因为使用了`scss`，需要安装sass解析。执行  `npm i -D sass@1.45.0` 安装 sass

在`src/App.vue` 中为`img`标签增加一个 `class="bg-red-900"`，北京变红则表示成功。

### 3.4 tailwindcss初体验

**tailwind** 官方介绍为**无需离开HTML即可快速构建现代网络**。每一个类名背后都代表一个`css`属性

`tailwindcss`是一个非常富有争议的库，喜欢它的人和讨厌它的人都非常多。

### 3.5 tailwind设计理念和价值体现

1. **设计理念**

   - 原子化`css`：每一个类名所代表都是一个`css`属性（争议的核心）

     整个前端历史，`css`颗粒度设计主要分成4种形式（**颗粒度自上而下逐渐增大，颗粒度越大则约束性越高，可定制性越弱**）

     1. 行内样式：样式全部写入行内，自由度最高，可定制化最强，但是不方便样式的复用，每次都要写完整的样式。
     2. 原子化css：每一个类型都代表了一个css属性。自由度依然很强，可定制化依然很高，也方便复用。但是大量的样式会造成大量的类名。
     3. 传统形式：通过一个或几个具有语义化的 class 来描述一段css属性。封装性强，语义化强，自由度和可定制化性一般。但是大量的html需要大量的语义化class，并且在html和css中需要来回切换、查找。
     4. 组件形式：在组件库中极为常见。封装性极强（不光封装了样式，也封装了功能），语义化强。但是自由度和可定制化性比较差

2. **价值体现**

- **高定制化**

- **高个性化**

- **高交互性**

行内样式：无复用性，不适合！

组件样式：通用组件库，固定风格，不适合！

传统形式：响应式、主题替换等复杂功能实现复杂。

综上所述：原子化`CSS`，最合适

总结：

1. 如果想要实现一个**通用的后台项目**，那么推荐使用**通用组件库**实现。
2. 如果想要实现一个**高定制化、高个性化、高交互性**的前台项目，那么推荐使用`tailwindcs`实现

## 4 明星项目架构解决方案--搭建基础项目结构

### 4.2 项目开发助手Prettier - Code formatter、Tailwind CSS IntelliSense、volar

Prettier - Code formatter：代码格式管理

文件名：.prettierrc

```json
{
    "semi":false,  // 当前代码结尾不需要增加分号
    "singleQuote": true, // 使用单引号代替双引号
    "trailingComma": 'none', // 当前是否需药尾随逗号 
    
}
```

配置vue和js使用默认化：

鼠标右击，选择 **使用...格式化文档**，选择配置默认格式化程序 -> Prettier - Formatter

保存代码自动格式化：配置->**Editor:Format On Save** 勾选

Tailwind CSS IntelliSense：开发过程中类名提示

Volar：vue3推荐辅助工具

### 4.3 项目架构基本结构处理分析

响应式构建：一套代码实现移动端和PC端的显示。分析大的路由方案。然后分析某个模块的构建方案

移动端和PC端两者路由结构不一样。要展示的东西不一样。根据**当前用户所在设备不同，构建不同的路由表**，需要生成**多个路由表**来应对不同的情况。

### 4.4 构建项目架构

```json
| —— api // 接口请求
| —— assets // 静态资源文件
|    | —— icons // svg icon图标
|    | —— images // image图标， xxx.png
|    | —— logo.png // logo
| —— router // 路由
|    | —— index.js // 路由处理中心
|    | —— modules // 路由模块
|         | —— mobile-routes.js // 移动端路由
|         | —— pc-routes.js // PC段路由
| —— components // 通用的业务组件。比如：一个组件在多个页面中使用到
| —— constants // 常量
| —— directives // 自定义指令
| —— libs // 通用组件，可用于构建中台物料库或通用组件库
| —— main.js // 入口文件
| —— permission.js // 页面权限控制中心
| —— store // 全局状态
|    | —— getters.js // 全局状态访问处理
|    | —— index.js // 全局状态中心
|    | —— modules // 状态子模块
| —— style // 全局样式
|    | —— index.scss // 全局通用的样式处理
| —— util // 工具模块
| —— vendor // 外部供应资源，比如人类行为认证
| —— views // 页面组件，与components 的区别在于：此处组件对应路由表，以页面的形式展示
|    | —— layout // 用于PC端，分割一级路由和二级路由
|         | —— components // 该页面组件下的业务组件
|         | —— index.vue // layout组件
| —— tailwind.config.js // tailwind css 配置文件，与src平级
| —— vite.config.js // vite配置文件，与src平级
```

## 5 企业级vite配置方案

### 5.2 明确移动端和PC端的构建顺序

项目使用 `tailwindcss`。所以构建顺序需要尊重`tailwindcss`的构建顺序。

**移动优先**

使用tailwind构建响应式系统时，需要先构建移动端，再构建PC端

 ### 5.3 构建移动处理工具MobileTerminal

src/utils/flexble.js -> isMobileTerminal，结果不是响应式，需要切换刷新，有缺点，5.4优化

### 5.4 通过vueuse优化处理方案

[**vueuse中文网**](https://vueuse.nodejs.cn/) 方法响应式结果

```js
import { PC_DEVICE_WIDTH } from '@/constants'
// PC 设备指定宽度
// export const PC_DEVICE_WIDTH = 1280
import { useWindowSize } from '@vueuse/core'
const { width } = useWindowSize()
// 不用自动刷新也会计算
export const isMobileTerminal = computed(() => {
  return width.value < PC_DEVICE_WIDTH
})
```

### 5.5 定义@软链接

引用文件相对路./径改成@开头的软链接 **[resolve.alias](https://cn.vitejs.dev/config/shared-options.html#resolve-alias)**

```js
// vite.config.js
import path, { join } from 'path'

export default defineConfig({
  ...
  // 软链接
  resolve: {
    alias: {
      '@': join(__dirname, '/src')
    }
  },
  ...
})
```

### 5.6 构建VueRouter移动端路由表

router/index.js

```js
import { createRouter, createWebHistory } from 'vue-router'
import { isMobileTerminal } from '@/utils/flexible'
// 移动端路由表
import mobileTerminalRoutes from './modules/mobile-routes'
// pc断路由表
import pcTerminalRoutes from './modules/pc-routes'

// 创建 vueRouter 实例
const router = createRouter({
  // history 使用哪种模式 hash模式 #开头
  history: createWebHistory(),
  // routes 路由表，移动端还是pc断路由表 isMobileTerminal
  routes: isMobileTerminal.value ? mobileTerminalRoutes : pcTerminalRoutes
})

export default router

```

main.js中导入注册

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
...
createApp(App).use(router).mount('#app')

...
```

App.vue 中保留一个一级路由出口

```vue
<template>
  <!-- 一级路由出口 -->
   <router-view></router-view>
</template>

<script setup></script>

<style lang="scss" scoped></style>
```

### 5.7 划分移动端首页模块

### 5.8 导入并配置axios

安装：npm install --save axios@0.26.1

创建 src/utils.request.js

```js
import axios from 'axios'
import store from '@/store'
import { message as $message } from '@/libs'

const service = axios.create({
  baseURL: import.meta.env.VITE_BASE_API,
  timeout: 5000
})

// 请求拦截器
service.interceptors.request.use(
  (config) => {
    config.headers.icode = '你需要在这里填入你的 icode'
    if (store.getters.token) {
      // 如果token存在 注入token
      config.headers.Authorization = `Bearer ${store.getters.token}`
    }
    return config // 必须返回配置
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
service.interceptors.response.use(
  (response) => {
    const { success, message, data } = response.data
    //   要根据success的成功与否决定下面的操作
    if (success) {
      return data
    } else {
      $message('warn', message)
      // TODO：业务错误
      return Promise.reject(new Error(message))
    }
  },
  (error) => {
    // 处理 token 超时问题
    if (
      error.response &&
      error.response.data &&
      error.response.data.code === 401
    ) {
      // TODO: token超时
      store.dispatch('user/logout')
    }
    $message('error', error.response.data.message)
    // TODO: 提示错误消息
    return Promise.reject(error)
  }
)

export default service
```



### 5.9 vite 处理代理服务器

**[server.proxy](https://cn.vitejs.dev/config/server-options.html#server-proxy)**

```js
// vite.config.js
import path, { join } from 'path'

export default defineConfig({
  ...
 // 代理
  server: {
    proxy: {
      // 代理所有 /api 的请求，该求情将被代理到 target 中
      '/api': {
        // 代理请求之后的请求地址
        target: 'https://api.imooc-front.lgdsunday.club/',
        // 跨域
        changeOrigin: true
      }
    }
  }
})
```

### 5.10 vite处理环境变量

**[.env文件](https://cn.vitejs.dev/guide/env-and-mode.html#env-files)**

开发环境  .env.development

```bash
# 只在指定模式（development）下加载

# base api, 只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理
VITE_BASE_API = '/api'

```

生产环境 .env.production

```bash
# base api, 只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理
VITE_BASE_API = '/prod-api'

# 只有 VITE_SOME_KEY 会被暴露为 import.meta.env.VITE_SOME_KEY 提供给客户端源码，而 DB_PASSWORD 则不会。
# VITE_SOME_KEY=123
# DB_PASSWORD=foobar

# console.log(import.meta.env.VITE_SOME_KEY) // "123"
# console.log(import.meta.env.DB_PASSWORD) // undefined
```

utils/request.js

```js
...
const service = axios.create({
  baseURL: import.meta.env.VITE_BASE_API, // 修改此处
  timeout: 5000
})
...
```

**[anywhere](https://www.npmjs.com/package/anywhere)** ：随起随用的静态文件服务器

`npm install anywhere -g`

进入打包过后的dist文件夹下。`vscode`命令行敲 anywhere 开启服务。查看项目发布

## 6 构建自己的物料解决方案-构建物料库，实现前端设计

物料库即组件库。

### 6.5 动态rem基准+修正tailwind，完善移动端navigator

1、动态rem基准

utils/flexible.js

```js
/**
 * 初始化 rem 基准值，最大为 40px
 
 */
export const useREM = () => {
  // 定义最大的 fontSize
  const MAX_FONT_SIZE = 40

  // 监听 html 文档被解析完成的事件
  document.addEventListener('DOMContentLoaded', () => {
    // 获取 html 标签
    const html = document.querySelector('html')
    // 获取根元素 fontSize 标准，屏幕宽度 / 10。（以 Iphone 为例 Iphone 6 屏幕宽度为 375，则标准 fontSize 为 37.5）
    let fontSize = window.innerWidth / 10
    // 获取到的 fontSize 不允许超过我们定义的最大值
    fontSize = fontSize > MAX_FONT_SIZE ? MAX_FONT_SIZE : fontSize
    // 定义根元素（html）fontSize 的大小 （rem）
    html.style.fontSize = fontSize + 'px'
  })
}
```

main.js

```js
import { useREM } from './utils/flexible'

// 设置 rem
useREM()
```

2、修正 **[tailwind Font-Size](https://tailwindcss.com/docs/font-size)**

tailwind.config.js

```js
module.exports = {
	theme: {
		extend: {
			...
            fontSize: {
                // 第一个是font-size 第二个是line-height
        		xs: ['0.25rem', '0.35rem'],
       		 	sm: ['0.35rem', '0.45rem'],
        		base: ['0.42rem', '0.52rem'],
       		 	lg: ['0.55rem', '0.65rem'],
        		xl: ['0.65rem', '0.75rem']
     		}
            ...
		}
	}
}
```

### 6.7 基于vite的统一svg处理svg-icon

src/libs/svg-icon/index.vue

```vue
<template>
  <svg aria-hidden="true">
    <use :class="fillClass" :xlink:href="symbolId" :fill="color" />
  </svg>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  // 显示的 svg 图标名称（剔除 icon-）
  name: {
    type: String,
    required: true
  },
  // 直接指定 svg 图标的颜色
  color: {
    type: String
  },
  // 通过 tailwind 指定 svg 颜色的类名
  fillClass: {
    type: String
  }
})
// 真实显示的 svg 图标名（拼接 #icon-）
const symbolId = computed(() => `#icon-${props.name}`)
</script>

```

src/libs/index.js 注册插件

```js
import { defineAsyncComponent } from 'vue'
export { confirm } from './confirm'
export { message } from './message'

export default {
  install(app) {
    // 获取当前路径任意文件夹下的 index.vue 文件
    const components = import.meta.glob('./*/index.vue')
    // 遍历获取到的组件模块
    for (const [key, value] of Object.entries(components)) {
      // 拼接组件注册的 name
      const componentName = 'm-' + key.replace('./', '').split('/')[0]
      // 通过 defineAsyncComponent 异步导入指定路径下的组件
      app.component(componentName, defineAsyncComponent(value))
    }
  }
}

```

main.js中注册

```js
import mLibs from './libs'

createApp(App).use(mLibs).mount('#app')
```

tailwind 自定义样式

tailwind.config.js

```
module.exports = {
	theme: {
		extend: {
			...
            boxShadow: { // 阴影
        		'l-white': '-10px 0 10px white',
        		'l-zinc': '-10px 0 10px #18181b'
      		}
            ...
		}
	}
}
```

### 6.8 vite处理svg矢量图

```bash
npm install --save-dev vite-plugin-svg-icons@2.0.1
```

vite.config.js

```js
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'
import path, { join } from 'path'

export default defineConfig({
    ...
    plugins: [
    vue(),
    createSvgIconsPlugin({
      // 指定需要缓存的图标文件夹
      iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],
      // 指定symbolId格式
      symbolId: 'icon-[name]'
    })
  	],
    ...
})

```

在main.js中注册icon

```js
// 注册 svg-icons 导入的地址是固定的
import 'virtual:svg-icons-register'
```

### 6.9  移动端slider处理

**[element.getBoundingClientRect()](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)** 。该对象有6个属性：[top](https://so.csdn.net/so/search?q=top&spm=1001.2101.3001.7020),lef,right,bottom,width,height；

返回值：

```json
{
  bottom：430, //元素底部距离窗口顶部的距离 (等于 y + height)
  height:340, //元素的高度
  left:120, //元素左侧距离窗口左侧的距离
  right:460, //元素右侧距离窗口左侧的距离(等于 x + width)
  top:90, //元素顶部距离窗口的距离
  width:340, //元素的宽度
  x:120, //元素左上角相对于视口的横坐标
  y:90 //元素左上角相对于视口的纵坐标
}
```

### 6.12 通用组件：弹出窗口-popup实现

**[useScrollLock](https://vueuse.nodejs.cn/core/useScrollLock/)**、**[useVModel](https://vueuse.nodejs.cn/core/useVModel/#usage)**

teleport、transition动画

```js
import { useScrollLock } from '@vueuse/core'
import { useVModel } from '@vueuse/core'

// 通过 useVModel 获取到响应式数据 isOpen，当 isOpen 改变时，会自动触发 update:modelValue
const isOpen = useVModel(props)
// ------ 滚动锁定 ------
const isLocked = useScrollLock(document.body)
```

通过` import { useVModel } from '@vueuse/core' `优化组件间双向数据绑定功能。

### 6.14 vite通用组件自动化注册

**vite 提供的功能，进行通用组件的自动化注册**，需要使用到两个关键的知识点：

1. **[vite的Glob导入功能](https://cn.vitejs.dev/guide/features.html#glob-import)**：该功能可以帮助我们在 **文件系统中导入多个模块**
2. vue 的 defineAsyncComponent方法：该方法可以创建一个 **按需加载的异步组件**

基于以上两个方法，实现组件自动注册

在 src/libs/index.js 中：

```js
import { defineAsyncComponent } from 'vue'
export { confirm } from './confirm'
export { message } from './message'

export default {
  install(app) {
    // 获取当前路径任意文件夹下的 index.vue 文件
    const components = import.meta.glob('./*/index.vue')
    // 遍历获取到的组件模块
    for (const [key, value] of Object.entries(components)) {
      // 拼接组件注册的 name
      const componentName = 'm-' + key.replace('./', '').split('/')[0]
      // 通过 defineAsyncComponent 异步导入指定路径下的组件
      app.component(componentName, defineAsyncComponent(value))
    }
  }
}
```

总结：

1. 定义了两个通用组件。svg-icon、propup。
2. 修正了 rem 值，对于移动端的 rem 处理目前可以根据设备的不同来自动修正。
3. 基于 vite 的 svg 矢量图导入和自动组件注册。
4. 介绍了 vueuse 中更多的功能方法。

## 7. 企业级通用业务Header处理方案

### 7.2 处理PC端基础架构

动态计算PC端的高度，结合tailwindcss 配置

tailwind.config.js 

```js
module.exports = {
  ...
  theme: {
    extend: {
      height: {
        header: '72px',
        main: 'calc(100vh - 72px)'
      },
      ...
    }
  },

}

```

src/views/layout/index.vue

```vue
<template>
  <div class="h-screen">
    <!-- 需要在 tailwind 中定义 h-header、h-main 高度 -->
    <header-vue class="h-header"></header-vue>
    <div class="h-main">
      <main-vue></main-vue>
    </div>
    <floating-vue></floating-vue>
  </div>
</template>
```

### 7.3 PC端Header模块处理分析与简单实现

### 7.4 通用组件：search搜索框能力分析

功能分析：

1. 输入内容实现双向数据绑定
2. 鼠标移入与获取焦点时的动画
3. 一键清空文本功能
4. 搜索触发功能
5. 可控制，可填充的下拉展区
6. 监听到以下事件列表：
   1. clear：删除所有文本事件
   2. input：输入事件
   3. focus：获取焦点事件
   4. blur：失去焦点事件
   5. search：触发搜索（点击或回车）事件

### 7.7 通用组件：button按钮功能实现

1. 构建 type 风格可选项和 size 大小可选项
2. 通过 props 让开发者控制按钮
3. 区分 icon button 和 text button
4. 依据当前的数据，实现视图
5. 处理点击事件

src/libs/button/index.vue

```vue
<template>
  <button
    class="text-sm text-center rounded duration-150 flex justify-center items-center"
    :class="[
      typeEnum[type],
      sizeEnum[sizeKey].button,
      { 'active:scale-105': isActiveAnim }
    ]"
    @click.stop="onBtnClick"
  >
    <!-- 展示 loading -->
    <m-svg-icon
      v-if="loading"
      name="loading"
      class="w-2 h-2 animate-spin mr-1"
    ></m-svg-icon>
    <!-- icon 按钮 -->
    <m-svg-icon
      v-if="icon"
      :name="icon"
      class="m-auto"
      :class="sizeEnum[sizeKey].icon"
      :color="iconColor"
      :fillClass="iconClass"
    ></m-svg-icon>
    <!-- 文字按钮 -->
    <slot v-else />
  </button>
</template>

<script>
import { computed } from 'vue'

// type 可选项：表示按钮风格
const typeEnum = {
  primary:
    'text-white  bg-zinc-800 dark:bg-zinc-900  hover:bg-zinc-900 dark:hover:bg-zinc-700 active:bg-zinc-800 dark:active:bg-zinc-700',
  main: 'text-white  bg-main dark:bg-zinc-900  hover:bg-hover-main dark:hover:bg-zinc-700 active:bg-main dark:active:bg-zinc-700',
  info: 'text-zinc-800 dark:text-zinc-300  bg-zinc-200 dark:bg-zinc-700 hover:bg-zinc-300 dark:hover:bg-zinc-600 active:bg-zinc-200 dark:active:bg-zinc-700 '
}
// size 可选项：表示按钮大小。区分文字按钮和icon按钮
const sizeEnum = {
  default: {
    button: 'w-8 h-4 text-base',
    icon: ''
  },
  'icon-default': {
    button: 'w-4 h-4',
    icon: 'w-1.5 h-1.5'
  },
  small: {
    button: 'w-7 h-3 text-base',
    icon: ''
  },
  'icon-small': {
    button: 'w-3 h-3',
    icon: 'w-1.5 h-1.5'
  }
}

const EMITS_CLICK = 'click'
</script>
<script setup>
const props = defineProps({
  // icon 图标名字
  icon: {
    type: String
  },
  // icon 图标颜色
  iconColor: {
    type: String
  },
  // icon 图标类名（匹配 tailwind）
  iconClass: {
    type: String
  },
  // 按钮风格
  type: {
    type: String,
    default: 'main',
    validator(val) {
      // 获取所有的可选的按钮风格
      const keys = Object.keys(typeEnum)
      // 开发者指定风格是否在可选风格中
      const result = keys.includes(val)
      // 如果不在则给开发者提示
      if (!result) {
        throw new Error(`你的 type 必须是 ${keys.join('、')} 中的一个`)
      }
      // 返回校验结果
      return result
    }
  },
  // 大小风格
  size: {
    type: String,
    default: 'default',
    validator(val) {
      // 获取所有的可选的大小（注意剔除 icon 开头的元素，因为我们期望开发者输入 size="default"，但不期望开发者输入 size="icon-default"）
      const keys = Object.keys(sizeEnum).filter((key) => !key.includes('icon'))
      // 开发者指定大小是否在可选大小中
      const result = keys.includes(val)
      // 如果不在则给开发者提示
      if (!result) {
        throw new Error(`你的 size 必须是 ${keys.join('、')} 中的一个`)
      }
      // 返回校验结果
      return result
    }
  },
  // 按钮在点击时是否需要动画
  isActiveAnim: {
    type: Boolean,
    default: true
  },
  // 加载状态
  loading: {
    type: Boolean,
    default: false
  }
})

const emits = defineEmits([EMITS_CLICK])

// 处理大小的 key 值
const sizeKey = computed(() => {
  return props.icon ? 'icon-' + props.size : props.size
})

/**
 * 按钮点击事件处理
 */
const onBtnClick = () => {
  if (props.loading) {
    return
  }
  emits(EMITS_CLICK)
}
</script>

<style lang="scss" scoped></style>
```

### 7.10 通用组件：popover气泡卡片能力分析

### 7.15 通用组件：处理慢速移动时，气泡消失问题

因为在 `reference` 与气泡之间存在间隙，鼠标移动到间隙处就会消失。就会触发`mouseleave` 鼠标移出事件，此时`isVisiable` 就会变成`false`

想要解决这个问题，我们可以利用 **类似于防抖（`debounce`）**的概念。

也就是：鼠标刚离开时，不立刻修改`isVisiable`，而是延迟一段时间，如果在这段时间之内，再次触发了鼠标移入时间，则不再修改` isVisiable`

以此来解决慢速移动的问题。

```js
// 延迟关闭时长
const DELAY_TIME = 100

// 控制延迟关闭
let timeout = null
/**
 * 鼠标移入的触发行为
 */
const onMouseenter = () => {
  isVisable.value = true
  // 再次触发时，清理延时装置
  if (timeout) {
    clearTimeout(timeout)
  }
}
/**
 * 鼠标移出的触发行为
 */
const onMouseleave = () => {
  // 延时装置
  timeout = setTimeout(() => {
    isVisable.value = false
    timeout = null
  }, DELAY_TIME)
}
```

## 8. 企业级复杂前中台项目响应式处理方案

响应式（多指响应式布局：一套样式在多段展示）

### 8.2 响应式下 navigationBar 实现方案分析

通常情况下，复杂功能的响应式处理，我们一般有三种解决方案：

1. 一套代码处理多端：
   1. 优势：代码数量相对较少
   2. 劣势：耦合性强，不利于后期维护

2. 多套代码分别处理各端：
   1. 优势：逻辑清晰
   2. 劣势：可能会产生很多重复性的逻辑

3. 结合以上两种方案：抽离共用逻辑，封装私有逻辑：

   1. 优势：结合以上两种优势

   2. 劣势：需要对业务和逻辑足够清楚

功能由两部分组成：

1. 数据：双端数据是一样的，可以复用，通过 `vuex`来封装公有数据这一系列的 **获取、切换**行为。
2. 视图：展示视图逻辑相差大，为了综合维护，不同端单独封装私有部分，需要在各自组建单独处理。

### 8.4 PC端navigationBar私有视图处理

### 8.5 PC端navigationBar私有逻辑处理

### 8.6 分析navigationBar闪烁问题

手动刷新的时候，navigation会闪烁。

1. 先让 categorys 具备一个初始化数据。
2. 从服务端获取数据，替换初始化数据
3. 为了防止初始化数据太老，我们把每次获取到的新数据，都作为下一次的初始化数据。

### 8.7 处理navigationBar闪烁问题

**解决1和2**。保留部分常用的，不用留全部。

src/constants/index.js

```js
// 初始 category 数据
export const CATEGORY_NOMAR_DATA = [
  ALL_CATEGORY_ITEM,
  { id: 'web_app_icon', name: 'UI/UX' },
  { id: 'design', name: '平面' },
  { id: 'illustration', name: '插画/漫画' },
  { id: 'photography', name: '摄影' },
  { id: 'games', name: '游戏' },
  { id: 'anime', name: '动漫' },
  {
    id: 'industrial_design',
    name: '工业设计'
  },
  {
    id: 'industrial_design',
    name: '建筑设计'
  },
  {
    id: 'industrial_design',
    name: '人文艺术'
  },
  {
    id: 'industrial_design',
    name: '家居/家装'
  }
]
```

src/store/modules/category.js

```js
import { getCategory } from '@/api/category'
import { ALL_CATEGORY_ITEM, CATEGORY_NOMAR_DATA } from '@/constants'

export default {
  // 独立作用域
  namespaced: true,
  state: () => ({
    // navigationBar 展示的数据源
    categorys: CATEGORY_NOMAR_DATA
  }),
  mutations: {
    /**
     * 为 categorys 赋值的统一操作
     */
    setCategorys(state, categorys) {
      state.categorys = [ALL_CATEGORY_ITEM, ...categorys]
    }
  },
  actions: {
    /**
     * 将从接口获取得了数据的异步逻辑放到 store 的 actions 中
     * 获取 category 数据，并自动保存到 vuex 中
     */
    async useCategoryData(context) {
      const { categorys } = await getCategory()
      context.commit('setCategorys', categorys)
    }
  }
}

```

**解决3**：为了防止初始化数据太老，我们把每次获取到的新数据，都作为下一次的初始化数据。

**方案**：每次获取到的新数据，进行缓存。在下次运行时，把缓存的数据作为初始值

category数据缓存，覆盖初始数据。利用**[vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate#readme)**

src/router/index.js

```js
import createPersistedState from 'vuex-persistedstate'

const store = createStore({
  getters,
  modules: {
    category,
    theme,
    app,
    search,
    user
  },
  plugins: [
      // 数据缓存
    createPersistedState({
      // 保存到 localStorage 中的 key
      key: 'imooc-front',
      // 需要保存的模块，只有被放入的模块才会自动执行被缓存
      paths: ['category', 'theme', 'search', 'user']
    })
  ]
})

export default store
```

## 9. 主题替换解决方案

基于tailwind的主题替换

### 9.1 主题替换原理分析

原理：通过类名来控制对应的样式（主题），当类名发生改变时，即完成了主题替换。

### 9.3 tailwindDarkMode原理

利用 **[DarkMode](https://tailwindcss.com/docs/dark-mode)** 实现主题替换

1. 给对应的组件DOM添加`dark css`样式
2. 给 `html` 跟标签增加class=“dark"的样式

tailwind.config.js 配置

```js
module.exports = {
  // 手动切换暗模式
  darkMode: 'class',
  ...
}
```

### 9.4 为组件增加dark适配

### 9.5 DarkMode在复杂应用中的实现逻辑分析

**处理流程：**

1. 监听主题的切换行为 

   src/constants/index.js

   ```js
   // 暗黑主题
   export const THEME_DARK = 'dark'
   // 浅色主题
   export const THEME_LIGHT = 'light'
   // 系统主题
   export const THEME_SYSTEM = 'system'
   ```

   src/store/modules/theme.js

   ```js
   import { THEME_LIGHT } from '@/constants'
   export default {
     namespaced: true,
     state: () => ({
       // 主题模式
       themeType: THEME_LIGHT
     }),
     mutations: {
       /**
        *  切换主题模式
        */
       changeThemeType(state, newTheme) {
         state.themeType = newTheme
       }
     }
   }
   ```

   

2. 将当前切换主题保存到 `vuex `中

   src/views/layout/components/header/header-theme.vue

   ```js
   import { THEME_DARK, THEME_LIGHT, THEME_SYSTEM } from '@/constants'
   import { useStore } from 'vuex'
   // 构建渲染数据源
   const themeArr = [
     {
       id: '0',
       type: THEME_LIGHT,
       icon: 'theme-light',
       name: '极简白'
     },
     {
       id: '1',
       type: THEME_DARK,
       icon: 'theme-dark',
       name: '极夜黑'
     },
     {
       id: '2',
       type: THEME_SYSTEM,
       icon: 'theme-system',
       name: '跟随系统'
     }
   ]
   const store = useStore()
   /**
    * menu 切换事件
    * @param {*} theme
    */
   const onItemClick = (theme) => {
     store.commit('theme/changeThemeType', theme.type)
   }
   ```

   

3. 根据 `vuex`中保存的当前主题，展示 header-theme下的显示图标

   src/views/layout/components/header/header-theme.vue

   ```js
   import { useStore } from 'vuex'
   import { computed } from 'vue'
   
   // 构建渲染数据源
   const themeArr = [
     {
       id: '0',
       type: THEME_LIGHT,
       icon: 'theme-light',
       name: '极简白'
     },
     {
       id: '1',
       type: THEME_DARK,
       icon: 'theme-dark',
       name: '极夜黑'
     },
     {
       id: '2',
       type: THEME_SYSTEM,
       icon: 'theme-system',
       name: '跟随系统'
     }
   ]
   
   // 控制图标展示
   const store = useStore()
   const svgIconName = computed(() => {
     // 根据当前的 themeType 返回当前的选中 icon
     const findTheme = themeArr.find((theme) => {
       return theme.type === store.getters.themeType
     })
     return findTheme?.icon || themeArr[0].type
   })
   ```

4. 根据 `vuex`中保存的当前主题，修改 `html` 的 class

   src/utils/theme.js

   ```js
   import store from '@/store'
   import { watch } from 'vue'
   import { THEME_LIGHT, THEME_DARK, THEME_SYSTEM } from '@/constants'
   
   /**
    * 监听系统主题变更
    */
   let matchMedia
   const watchSystemThemeChange = () => {
     // 仅需初始化一次即可
     if (matchMedia) return
     matchMedia = window.matchMedia('(prefers-color-scheme: dark)')
     // 监听主题变更
     matchMedia.onchange = function () {
       changeTheme(THEME_SYSTEM)
     }
   }
   
   /**
    * 变更主题
    * @param {*} theme 主题的标记常量
    */
   const changeTheme = (theme) => {
     // html 的 class
     let themeClassName = ''
     switch (theme) {
       case THEME_LIGHT:
         themeClassName = 'light'
         break
       case THEME_DARK:
         themeClassName = 'dark'
         break
       case THEME_SYSTEM:
         watchSystemThemeChange()
         themeClassName = matchMedia.matches ? 'dark' : 'light'
         break
     }
     // 修改 html 的 class
     document.querySelector('html').className = themeClassName
   }
   
   /**
    * 初始化主题
    */
   export default () => {
     watch(() => store.getters.themeType, changeTheme, {
       // 初始执行一次
       immediate: true
     })
   }
   
   ```

   main.js

   ```js
   ...
   import useTheme from './utils/theme'
   ...
   
   // 设置 rem
   useREM()
   // 初始化主题
   useTheme()
   createApp(App).use(router).use(store).use(mLibs).use(mDirective).mount('#app')
   ```

### 9.7 跟随系统的主题变更

跟随系统的主体变更

想要生成跟随系统主题变更，那么我们就需要 **监听系统的主题变化**

想要做到这一点，可以利用 **[Window.matchMedia()](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)**方法，该方法接受一个 `**mediaQueryString**` （媒介查询解析的字符串）

该字符串可以传递 **[prefers-color-schema](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme)** 

1. 该对象存在一个 **[change](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/change_event)** 事件，可以监听 主体发生变更 的行为。
2. 同时存在一个 **[matches](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/matches)** 属性， 该属性为 boolean 的值：
   1. true：深色主题
   2. false：浅色主题

src/utils/theme.js

```js
/**
 * 监听系统主题变更
 */
let matchMedia
const watchSystemThemeChange = () => {
  // 仅需初始化一次即可
  if (matchMedia) return
  matchMedia = window.matchMedia('(prefers-color-scheme: dark)')
  // 监听主题变更
  matchMedia.onchange = function () {
    changeTheme(THEME_SYSTEM)
  }
}
```

总结：主题替换的功能

1. 主题替换原理
2. tailwind 主题替换原理
3. 复杂应用中的实现方案
4. 跟随系统的主题变更

目前市面上很多的 **组件库** 也都包含了主题替换的功能，原理和本章讲的差不多。

## 10.瀑布流+长列表+懒加载处理方案

### 10.3 通用组件:瀑布流组件构建分析

列表展示展示：**瀑布流组件的构建过程**

**存在的问题**就是：**每个 item 应该横向排列，第二行的 item 顺序连接到当前最短的列中**，而这个也是构建瀑布流的核心逻辑。

要实现核心逻辑，**我们的每个 `item` 肯定就不可以使用正常的布局方式，而必须使用 `absolute` 绝对布局，通过`top`，` left `来手动控制位置**。

构建**瀑布流组件**分为几部分：

1. 通过 props 传递关键数据（部分）：
   1. data：数据源
   2. `nodeKey`：唯一标识
   3. column：渲染的列数
   4. `picturePreReadin`：是否需要图片预渲染
2. 瀑布流渲染机制：通过 `absolute` 配合 `relativ` 完成布局，布局逻辑为：**每个 item 应该横向排列，第二行的item顺序连接到当前最短的列中**
3. 通过 **作用域插槽** 将每个 item 中设计到的关键数据，传递到 item 视图中。

### 9.4 通用组件-瀑布流：构建瀑布流布局，获取容器宽度与列宽

`src/ibs/waterfall/index.vue` 核心逻辑

### 10.6 瀑布流：区分图片预加载，获取圆度关键属性

想要计算每列的 left，right，那么需要拿到每个 item 的高度，因为只有有了每一个 item 高，才可以判断下一列的第一个item 的位置。

同时根据`picturePreReading`又可以分为两种情况：

1. 需要图片预加载时，图片高度未知
2. 不需要图片预加载时，图片高度已知

根据以上分析可得出以下结论：

根据两种不同的情况，我们需要有两个不同的方法来计算

**图片预加载时**

1. 图片高度未知：

   ```js
   // item 高度集合
   let itemHeights = []
   /**
    * 监听图片加载完成
    */
   const waitImgComplate = () => {
     itemHeights = []
     // 拿到所有元素
     let itemElements = [...document.getElementsByClassName('m-waterfall-item')]
     // 获取所有元素的 img 标签
     const imgElements = getImgElements(itemElements)
     // 获取所有 img 标签的图片
     const allImgs = getAllImg(imgElements)
     onComplateImgs(allImgs).then(() => {
       // 图片加载完成，获取高度
       itemElements.forEach((el) => {
         itemHeights.push(el.offsetHeight)
       })
       // 渲染位置
       useItemLocation()
     })
   }
   ```

2. 以上使用到了多个工具方法，src/libs/waterfall/utils.js 模块进行处理

   ```js
   /**
    * 从 itemElement 中抽离出所有的 imgElements
    */
   export const getImgElements = (itemElements) => {
     const imgElements = []
     itemElements.forEach((el) => {
       imgElements.push(...el.getElementsByTagName('img'))
     })
     return imgElements
   }
   
   /**
    * 生成所有的图片链接数组
    */
   export const getAllImg = (imgElements) => {
     return imgElements.map((imgElement) => {
       return imgElement.src
     })
   }
   
   /**
    * 监听图片数组加载完成（通过 promise 完成）
    */
   export const onComplateImgs = (imgs) => {
     // promise 集合
     const promiseAll = []
     // 循环构建 promiseAll
     imgs.forEach((img, index) => {
       promiseAll[index] = new Promise((resolve, reject) => {
         const imageObj = new Image()
         imageObj.src = img
         imageObj.onload = () => {
           resolve({
             img,
             index
           })
         }
       })
     })
     return Promise.all(promiseAll)
   }
   
   /**
    * 返回列高对象中的最小高度所在的列
    */
   export const getMinHeightColumn = (columnHeightObj) => {
     const minHeight = getMinHeight(columnHeightObj)
     return Object.keys(columnHeightObj).find((key) => {
       return columnHeightObj[key] === minHeight
     })
   }
   
   /**
    * 返回列高对象中的最小的高度
    */
   export const getMinHeight = (columnHeightObj) => {
     const columnHeightArr = Object.values(columnHeightObj)
     return Math.min(...columnHeightArr)
   }
   
   /**
    * 返回列高对象中的最大的高度
    */
   export const getMaxHeight = (columnHeightObj) => {
     const columnHeightArr = Object.values(columnHeightObj)
     return Math.max(...columnHeightArr)
   }
   ```

**不需要图片预加载时**

1. 图片高度已知（接口自带）

   ```js
   /**
    * 图片不需要预加载时，计算 item 高度
    */
   const useItemHeight = () => {
     itemHeights = []
     // 拿到所有元素
     let itemElements = [...document.getElementsByClassName('m-waterfall-item')]
     // 计算 item 高度
     itemElements.forEach((el) => {
       // 依据传入数据计算出的 img 高度
       itemHeights.push(el.offsetHeight)
     })
     // 渲染位置
     useItemLocation()
   }
   ```

**渲染位置**

在 `useItemLocation` 方法中，打印所有的图片高度

```js
/**
 * 为每个 item 生成位置属性
 */
const useItemLocation = () => {
  // 遍历数据源
  props.data.forEach((item, index) => {
    // 避免重复计算
    if (item._style) {
      return
    }
    // 生成 _style 属性
    item._style = {}
    // left
    item._style.left = getItemLeft()
    // top
    item._style.top = getItemTop()
    // 指定列高度自增
    increasingHeight(index)
  })

  // 指定容器高度
  containerHeight.value = getMaxHeight(columnHeightObj.value)
}
```

### 10.10 通用组件-瀑布流：总结

瀑布流是一个比较复杂的通用组件，因为我们要尽量做到 **普适**，所以就需要考虑到各种场景下的处理方案，尽量可以满足日常开发的场景。所以这就在原本就复杂的前提下，让这个功能变得更加复杂了。

下面我们就再来梳理一下整个瀑布流的构建过程:

1. 瀑布流的核心就是:**通过 relative 和 absolute 定位的方式，来控制每个 item 的位置**
2. 影响瀑布流高度的主要元素，通常都是 **`img`** 标签
3. 有些服务端会返回 关键  **`img`**  的高度，有些不会，所以我们需要分别处理:
   1. 当服务端 **不返回** 高度时:我们需要等待 **`img`** 加载完成之后，再来计算高度，然后通过得到的高度计算定位。否则则会出现高度计算不准确导致定位计算不准确的问题。
   2. 当服务端 **返回** 高度时:开发者则必须利用此高度为 item 进行高度设定。一旦 item 具备指定高度，那么我们就不需要等待 **`img`** 加载的过程，这样效率更高，并且可以业务的逻辑会变得更加简单

4. 当进行响应式切换时，同样需要区分对应场景:
   1. 当服务端 **不返回** 高度时:我们需要 **重新执行整个渲染流程**，虽然会耗费一些性能，但是这样可以最大可能的避-免出现逻辑错误。让组件拥有**更强的普适性。**
   2. 当服务端 **返回** 高度时:我们同样需要重新计算 **列宽** 和 **定位**，但是因为 item 具备明确的高度，所以我们可以直接拿到具体的高度，而无需重复整个渲染流程，从而可以实现更多的交互逻辑。比如:位移动画、将来的图片懒加载占位.

### 10.11 通用组件：长列表infinite构建分析

**1. 长列表的实现原理**

所谓长列表分页加载，其实就是指：**当滚动到列表底部，加载数据**

想要实现这个功能，要做的核心一点就是能够**监听到列表滚动到底部**，可以利用 [**IntersectionObserver**](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver) ,该接口可以判断：**目标元素与其祖先元素或顶级文档视窗`viewport`的交叉状态（是否可见）**

利用这个特性，**把一个元素置于列表底部**，当这个元素可见时，则表示**列表滚动到了底部**

那么原生的 `IntersectionOberver` 使用起来比较复杂，所以 `**vueuse**` 提供了 [**useIntersectionObserver**](https://vueuse.nodejs.cn/core/useIntersectionObserver/#useintersectionobserver) 方法

**2.我们使用长列表时，希望如何进行使用**

```vue
<m-infinite-list
     v-model="" // 当前是否处于加载状态
     :isFinished="" // 数据是否全部加载完成
     @onLoad="" // 加载下一页数据的触发事件
>
</m-infinite-list>
```

### 10.15 通用组件：解决首次数据无法铺满全屏时，数据无法继续加载

当首次加载的数据无法铺满全屏时，我们的数据无法继续加载。

原因：只触发了一次 `isIntersecting`

```js
// 处理 loading 状态
const loading = useVModel(props)

// 滚动的元素
const laodingTarget = ref(null)
// 记录当前是否在底部（是否交叉）
const targetIsIntersecting = ref(false)
useIntersectionObserver(
  laodingTarget,
  ([{ isIntersecting }], observerElement) => {
    // 获取当前交叉状态
    // 当加载更多的视图可见时，处理加载更多的逻辑
    targetIsIntersecting.value = isIntersecting
    // 触发 load
    emitLoad()
  }
)

/**
 * 触发 load
 */
const emitLoad = () => {
  // 当加载更多的视图可见时，加载更多数据，同时loading 为 false ，同时数据尚未全部加载完
  if (targetIsIntersecting.value && !loading.value && !props.isFinished) {
    // 修改加载数据标记
    loading.value = true
    // 触发加载更多行为
    emits('onLoad')
  }
}

/**
 * 监听 loading 的变化，解决数据加载完成后，首屏未铺满的问题，有点点性能问题，可以延迟执行，让其修改状态
 */
watch(loading, (val) => {
  // 触发 load，延迟处理，等待 渲染和 useIntersectionObserver 的再次触发
  setTimeout(() => {
    emitLoad()
  }, 100)
})
```

### 10.16 图片懒加载构建原因+实现原理

当 `query.size` 修改为100， 看到一次请求家在很多图片。请求次数有500多次

但是首屏看不到400多张图片，多余的请求就变得很浪费了。

用**图片懒加载实现功**能：减少多余的浪费请求

图片懒加载原理：**当图片不可见时，不加载图片，当图片可见时，采取加载图片。**

**可见**和**不可见**就是实现**长列表**时用过的套路

**监听所有图片是否可见，如果图片处于不可见状态，那么就不加载图片，如果图片处于可见状态，那么开始加载图片。**

这个功能的实现关键就是 **`IntersectionObserver`**

### 10.17 通用指令：实现图片懒加载

src/directives/modules/lazy.js

```js
import { useIntersectionObserver } from '@vueuse/core'

export default {
  // 图片懒加载：在用户无法看到图片时，不加载图片，在用户可以看到图片后加载图片
  // 如何判断用户是否看到了图片：useIntersectionObserver
  // 如何做到不加载图片（网络）：img 标签渲染图片，指的是 img 的 src 属性，src 属性是网络地址时，则会从网络中获取该图片资源。那么如果 img 标签不是网络地址呢？把该网络地址默认替换为非网络地址，然后当用户可见时，在替换成网络地址。
  mounted(el) {
    // 1. 拿到当前 img 标签的 src
    const imgSrc = el.src
    // 2. 把 img 标签的 src 替换为本地地址,图片都会消失，或者占位图片都可以
    el.src = ''

    // 3. 当图片区域可见，显示图片
    const { stop } = useIntersectionObserver(el, ([{ isIntersecting }]) => {
      if (isIntersecting) {
        el.src = imgSrc
        // 4. 加载完以后停止监听
        stop()
      }
    })
  }
}
```

### 10.18 深入`vite`：指令的自动注册

如果指令过得多，那么需要一个一个注册未免过于麻烦了，所以最好有一种方式 **指令的自动注册**

利用Glob导入（[`import.meta.globEager`）](https://cn.vitejs.dev/guide/features.html#glob-import) 和 [`Object.entrues`](https://web.nodejs.cn/en-us/docs/web/javascript/reference/global_objects/object/entries/) 功能

```js
/**
 * 全局指令注册
 */
export default {
  async install(app) {
    // https://cn.vitejs.dev/guide/features.html#glob-import
    // import.meta.globEager 为同步导入
    const directives = import.meta.globEager('./modules/*.js')
    for (const [key, value] of Object.entries(directives)) {
      // 拼接组件注册的 name
      const arr = key.split('/')
      const directiveName = arr[arr.length - 1].replace('.js', '')
      // 完成注册
      app.directive(directiveName, value.default)
    }
  }
}
```

### 10.19 指定彩色占位图

图片没有加载出来的时候，给出各种各样颜色点的占位符

src/utils/color.js

```js
/**
 * 生成随机色值
 */
export const randomRGB = () => {
  const r = Math.floor(Math.random() * 255)
  const g = Math.floor(Math.random() * 255)
  const b = Math.floor(Math.random() * 255)
  return `rgb(${r}, ${g}, ${b})`
}

```

src/views/main/components/list/item.vue

```vue
<template>
...
	<div
      class="relative w-full rounded cursor-zoom-in group"
      :style="{
        backgroundColor: randomRGB()
      }"
      @click="onToPinsClick"
    >
 ...
</template>

<script setup>
    ...
import { randomRGB } from '@/utils/color'
    ...
</script>
```

## 11. 多组件联动与高阶组件方案

### 11.2 多组件联动注意事项与整体逻辑分析

 多组件联动：**多个组件之间，存在一个或多个共享的数据，当数据发生改变时，执行对应的逻辑。**

拆分：

1. 多组件之间需要共享数据
2. 监听数据变化，并执行对应逻辑

**多组件之间需要共享数据方式**：

1. 组件之间的数据传递 —— 常见于层级关系比较清晰的多组件之中
   1. 父传子
   2. 子传父
   3. ...

2. 依赖注入：**Provide/ Inject** —— 嵌套层级比较深，并且子组件只需要父组件的部分内容

3. 全局状态管理工具：**`Vuex`** —— 以上两种情况都不适用的情况下

**监听数据变化的方式：**

当组件之间的共享数据发生变化，我们需要执行对应的逻辑操作。所以首先就需要监听到数据的变化。

在 vue 中监听数据变化的方式，首推就是 **watch**

**整体逻辑分析：**

1. 创建共享数据对应的 `vuex` 模块
2. 在 `getters` 中建立对应的快捷访问计算属性
3. 在对应的业务组件中，监听 `getters`，并执行对应逻辑

当 watch 监听 vuex 的 store 的时候，需要传递函数，而不是直接访问 store.getters.currentCategoryIndex

 应该是要写成函数形式

```js
watch(
  // watch 监听 getters 的时候，我们需要传递一个函数。原因待查明
  () => store.getters.currentCategoryIndex,
  (val) => {
    // 获取选中元素的 left、width
    const { left, width } = itemRefs[val].getBoundingClientRect()
    // 为 sliderStyle 设置属性
    sliderStyle.value = {
      // ul 横向滚动位置 + 当前元素的 left 偏移量
      transform: `translateX(${ulScrollLeft.value + left - 10 + 'px'})`,
      width: width + 'px'
    }
  }
)
```

### 11.4 明确 searchBar 对应的 list 处理流程

1. 搜索提示（高亮）
2. 搜索历史 （删除历史）
3. 推荐主题
4. search 触发时的 list 联动

### 11.5 searchBar：搜索提示初步实现

实现搜索提示：

```js
import { getHint } from '@/api/pexels'
import { ref } from 'vue'
import { watchDebounced } from '@vueuse/core'
/**
 * 处理搜索提示数据获取
 */
const hintData = ref([])
const getHintData = async () => {
  if (!props.searchText) return
  const { result } = await getHint(props.searchText)
  hintData.value = result
}
/**
 * 监听搜索文本的变化，并获取对应提示数据
 * watch 可以监听一个 ref 响应式数据，或者一个包含 getters 的函数
 */
watchDebounced(() => props.searchText, getHintData, {
  immediate: true,
  // 每次事件触发时，延迟的时间
  debounce: 500
})
```

### searchBar：处理防抖功能

所谓防抖：**当触发一个事件时，不立刻立即执行，而是延迟一段时间，改时间变为等待执行事件。如果在这段时间之内，该事件被再次触发，则上次等待执行的事件取消，本次触发的事件变为等待执行事件。往复循环，直到某一等待事件被执行为止。这样的防抖，**我们通常称为：**`debounce`**

这样的防抖，就需要再watch中处理， `vueuse` 中提供了对应的 **[`watchDebounce`](https://vueuse.nodejs.cn/shared/watchDebounced/#usage)**，我们可以利用这个 **`API`** 直接实现防抖的 watch。

### 11.7 searchBar：提示关键字高亮处理

src\views\layout\components\header\header-search\hint.vue

```vue
<template>
  <div class="">
    <div
      v-for="(item, index) in hintData"
      :key="index"
      class="py-1 pl-1 text-base font-bold text-zinc-500 rounded cursor-pointer duration-300 hover:bg-zinc-200 dark:hover:bg-zinc-900"
      @click="onItemClick(item)"
      v-html="highlightText(item)"
    ></div>
  </div>
</template>
<script>
    ...
/**
 * 处理关键字高亮
 */
const highlightText = (text) => {
  // 生成高亮标签
  const highlightStr = `<span class="text-zinc-900 dark:text-zinc-200">${props.searchText}</span>`
  // 构建正则表达式，从《显示文本中》找出与《用户输入文本相同的内容》，使用《高亮标签》进行替换
  const reg = new RegExp(props.searchText, 'gi')
  // 替换
  return text.replace(reg, highlightStr)
}
</script>
```

### 11.8 searchBar：搜索历史处理

### 11.9 通用组件：confirm应用场景

希望构建一个像 element-plus 中的 confirm 一样，可以直接通过方法的形式调用。自己构建

### 11.10 通用组件：vnode+h函数+render函数明确confirm构建思路

**渲染函数：**

1. 虚拟`dom`：通过`js`来描述`dom`
2. `vnode`虚拟节点：告诉`vue`页面上需要渲染什么样自的节点
3. `h`函数：用来创建`vnode`的函数，接受3个参数（要渲染的`dom`组件，`attrs`对象，子元素）
4. `render`函数：可以根据`vnode`来渲染

根据以上所说我们知道：通过h函数可以生成一个`vnode`，该`vnode `可以通过render函数被渲染

1. 创建一个` confirm `组件
2. 创建一个`confirm.js`模块，在该模块中**返回一个 `promise`**
3. 同时利用h函数生成 `confirm.vue` 的v`node`
4. 最后利用` render `函数渲染`vnode`到`body`中

### 11.11 通用组件：构建confirm组件

src\libs\confirm\index.js  通过导改js，通过方法来使用 confirm

```js
import { h, render } from 'vue'
import confirmComponent from './index.vue'

/**
 * 展示 confirm，用户只传递一个参数，那么这个参数为 content
 * @param {*} title 标题（如果用户没有传递内容，那么标题被作为内容）
 * @param {*} content 文本（如果没有title,那么content会被作为第一个参数传入）
 * @param {*} cancelText 取消按钮文本
 * @param {*} confirmText 确定按钮文本
 * @returns
 */
export const confirm = (
  title,
  content,
  cancelText = '取消',
  confirmText = '确定'
) => {
  return new Promise((resolve, reject) => {
    // 允许只传递 content
    // 用户值传递一个参数，把这个参数当做content来处理。不显示 title
    if (title && !content) {
      content = title
      title = ''
    }

    // 关闭弹层事件，把渲染的vnode去掉
    const close = () => {
      render(null, document.body)
    }

    // 取消按钮事件
    const cancelHandler = () => {
      reject(new Error('取消按钮点击'))
    }

    // 确定按钮事件
    const confirmHandler = () => {
      resolve()
    }

    // 1. 生成 vnode：虚拟 dom 节点
    const vnode = h(confirmComponent, {
      title,
      content,
      cancelText,
      confirmText,
      confirmHandler,
      cancelHandler,
      close
    })
    // 2. render 渲染：将虚拟 dom 渲染成真实 dom
    render(vnode, document.body)
  })
}
```

src\libs\confirm\index.vue

```vue
<template>
  <div>
    <!-- 蒙版 -->
    <transition name="fade">
      <div
        v-if="isVisable"
        @click="close"
        class="w-screen h-screen bg-zinc-900/80 z-40 fixed top-0 left-0"
      ></div>
    </transition>
    <!-- 内容 -->
    <transition name="up">
      <div
        v-if="isVisable"
        class="w-[80%] fixed top-1/3 left-[50%] translate-x-[-50%] z-50 px-2 py-1.5 rounded-sm border dark:border-zinc-600 cursor-pointer bg-white dark:bg-zinc-800 xl:w-[35%]"
      >
        <!-- 标题 -->
        <div class="text-lg font-bold text-zinc-900 dark:text-zinc-200 mb-2">
          {{ title }}
        </div>
        <!-- 内容 -->
        <div class="text-base text-zinc-900 dark:text-zinc-200 mb-2">
          {{ content }}
        </div>
        <!-- 按钮 -->
        <div class="flex justify-end">
          <m-button type="info" class="mr-2" @click="onCancelClick">{{
            cancelText
          }}</m-button>
          <m-button type="primary" @click="onConfirmClick">{{
            confirmText
          }}</m-button>
        </div>
      </div>
    </transition>
  </div>
</template>

<script setup>
// 因为将来 confirm 组件会以方法的形式展示调用，需要主动导入组件
import mButton from '../button/index.vue'
import { ref, onMounted } from 'vue'
const props = defineProps({
  // 标题
  title: {
    type: String
  },
  // 描述
  content: {
    type: String,
    required: true
  },
  // 取消按钮文本
  cancelText: {
    type: String,
    default: '取消'
  },
  // 确定按钮文本
  confirmText: {
    type: String,
    default: '确定'
  },
  // 取消按钮事件
  cancelHandler: {
    type: Function
  },
  // 确定按钮事件
  confirmHandler: {
    type: Function
  },
  // 关闭 confirm 的回调
  close: {
    type: Function
  }
})

// 控制显示处理
const isVisable = ref(false)
/**
 * confirm 展示
 */
const show = () => {
  isVisable.value = true
}
/**
 * 页面构建完成之后，执行。保留动画
 */
onMounted(() => {
  show()
})

// 关闭动画执行时间
const duration = '0.5s'
/**
 * confirm 关闭，保留动画执行时长
 */
const close = () => {
  isVisable.value = false
  // 延迟一段时间进行关闭，等待动画完全关闭之后，再去触发 props.close()
  setTimeout(() => {
    if (props.close) {
      props.close()
    }
  }, parseInt(duration.replace('0.', '').replace('s', '')) * 100)
}

/**
 * 取消按钮点击事件
 */
const onCancelClick = () => {
  if (props.cancelHandler) {
    props.cancelHandler()
  }
  close()
}

/**
 * 确定按钮点击事件
 */
const onConfirmClick = () => {
  if (props.confirmHandler) {
    props.confirmHandler()
  }
  close()
}
</script>

<style lang="scss" scoped>
.fade-enter-active,
.fade-leave-active {
  transition: all v-bind(duration);
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.up-enter-active,
.up-leave-active {
  transition: all v-bind(duration);
}

.up-enter-from,
.up-leave-to {
  opacity: 0;
  transform: translate3d(-50%, 100px, 0);
}
</style>
```

在逻辑页面中引用 confirm



```vue
<script>
import { useStore } from 'vuex'
import { confirm } from '@/libs'

...
/**
 * 删除所有记录
 */
const onDeleteAllClick = () => {
  confirm('要删除所有历史记录吗？')
    .then(() => {
      // 点击了确定
      store.commit('search/deleteAllHistory')
    })
    .catch(() => {
      console.log('点击了取消')
    })
}
...
</script>
```

### 11.15 总结

1. 多组件联动逻辑
2. confirm 通用组件
   1. vnode
   2. h 函数
   3. render 函数

## 12 前台常见功能解决方案：下载+全屏+引导

### 12.2 文件下载解决方案

当我们点击 item 中的 下载 按钮时，我们期望可以下载当前图片

需专门的下载包，目前常用的支持下载功能包两个

1. 小文件下载：**[file-saver](https://www.npmjs.com/package/file-saver)**  ：`npm install --save file-saver@2.0.5`
2. 大文件下载：**[streamsaver](https://www.npmjs.com/package/streamsaver)**

src\views\main\components\list\item.vue

```vue
<template>
...
<m-button
     class="absolute bottom-1.5 left-1.5 bg-zinc-100/70"
     type="info"
     size="small"
     icon="download"
     iconClass="fill-zinc-900 dark:fill-zinc-200"
      @click="onDownload"
 />
...
</template>
<script setup>
import { saveAs } from 'fil e-saver'
...
/**
 * 下载按钮点击事件
 */
const onDownload = () => {
  // 提示消息
  message('success', '图片开始下载')
  // 延迟一段时间执行，可以得到更好的体验
  setTimeout(() => {
    /**
     * 接收两个参数：
     * 1. 下载的图片链接
     * 2. 下载的文件名称
     */
    saveAs(
      props.data.photoDownLink,
      `${props.data.title} - 作者：${props.data.author}`
    )
  }, 100)
}
</script>
```

### 12.3通用组件：方法触发的message构建分析

1. 首先需要构建出一个对应的 message.vue
2. 然后构建出对应的message.js 模块
3. 在模块中，通过：
   1. h 函数 构建 `vnode`
   2. render 函数，进行渲染

### 12.4 通用组件：构建message组件基本能力

src\libs\message\index.vue

```vue
<template>
  <transition name="down" @after-leave="destroy">
    <div
      v-show="isVisable"
      class="min-w-[420px] fixed top-[20px] left-[50%] translate-x-[-50%] z-50 flex items-center px-3 py-1.5 rounded-sm border cursor-pointer"
      :class="styles[type].containerClass"
    >
      <m-svg-icon
        :name="styles[type].icon"
        :fillClass="styles[type].fillClass"
        class="h-1.5 w-1.5 mr-1.5"
      ></m-svg-icon>
      <span class="text-sm" :class="styles[type].textClass">
        {{ content }}
      </span>
    </div>
  </transition>
</template>

<script>
import mSvgIcon from '../svg-icon/index.vue'

/**
 * 消息类型可选项
 */
const typeEnum = ['success', 'warn', 'error']
</script>

<script setup>
import { ref, onMounted } from 'vue'
const props = defineProps({
  /**
   * message 的消息类型
   */
  type: {
    type: String,
    required: true,
    validator(val) {
      const result = typeEnum.includes(val)
      if (!result) {
        throw new Error(`你的 type 必须是 ${typeEnum.join('、')} 中的一个`)
      }
      return result
    }
  },
  /**
   * 描述文本
   */
  content: {
    type: String,
    required: true
  },
  /**
   * 展示时长
   */
  duration: {
    type: Number
  },
  /**
   * 关闭时的回调
   */
  destroy: {
    type: Function
  }
})

// 样式表数据
const styles = {
  // 警告
  warn: {
    icon: 'warn',
    fillClass: 'fill-warn-300',
    textClass: 'text-warn-300',
    containerClass:
      'bg-warn-100 border-warn-200  hover:shadow-lg hover:shadow-warn-100'
  },
  // 错误
  error: {
    icon: 'error',
    fillClass: 'fill-error-300',
    textClass: 'text-error-300',
    containerClass:
      'bg-error-100 border-error-200  hover:shadow-lg hover:shadow-error-100'
  },
  // 成功
  success: {
    icon: 'success',
    fillClass: 'fill-success-300',
    textClass: 'text-success-300',
    containerClass:
      'bg-success-100 border-success-200  hover:shadow-lg hover:shadow-success-100'
  }
}

// 控制显示处理
const isVisable = ref(false)
/**
 * 保证动画展示，需要在 mounted 之后进行展示
 */
onMounted(() => {
  isVisable.value = true
  /**
   * 延迟时间关闭
   */
  setTimeout(() => {
    isVisable.value = false
  }, props.duration)
})
</script>

<style lang="scss" scoped>
.down-enter-active,
.down-leave-active {
  transition: all 0.5s;
}

.down-enter-from,
.down-leave-to {
  opacity: 0;
  transform: translate3d(-50%, -100px, 0);
}
</style>

```

src\libs\message\index.js

```js
import { h, render } from 'vue'
import messageComponent from './index.vue'

export const message = (type, content, duration = 3000) => {
  /**
   * 动画结束时的回调
   */
  const onDestroy = () => {
    // 3. message 销毁
    render(null, document.body)
  }

  // 1. 返回 vnode
  const vnode = h(messageComponent, {
    type,
    content,
    duration,
    destroy: onDestroy
  })
  // 2. render
  render(vnode, document.body)
}
```

tailwind.config.js 配置文件自定义色值

```js
colors: {
    main: '#f44c58',
    'hover-main': '#f32836',
    'success-100': '#F2F9EC',
    'success-200': '#E4F2DB',
    'success-300': '#7EC050',
    'warn-100': '#FCF6ED',
    'warn-200': '#F8ECDA',
    'warn-300': '#DCA550',
    'error-100': '#ED7456',
    'error-200': '#f3471c',
    'error-300': '#ffffff'
  },
```

处理整个`message` 的`transittion`动画

```vue
<style lang="scss" scoped>
.down-enter-active,
.down-leave-active {
  transition: all 0.5s;
}

.down-enter-from,
.down-leave-to {
  opacity: 0;
  transform: translate3d(-50%, -100px, 0);
}
</style>
```

组件引用 src\views\main\components\list\item.vue

```js
import { message } from '@/libs'

/**
 * 下载按钮点击事件
 */
const onDownload = () => {
  // 提示消息
  message('success', '图片开始下载')
  // 延迟一段时间执行，可以得到更好的体验
  setTimeout(() => {
    /**
     * 接收两个参数：
     * 1. 下载的图片链接
     * 2. 下载的文件名称
     */
    saveAs(
      props.data.photoDownLink,
      `${props.data.title} - 作者：${props.data.author}`
    )
  }, 100)
}
```

### 12.6 模块全屏解决方案

让页面中的指定区域进行全屏展示是一种非常常见的一个功能。

通常可以使用 **[全屏AP](https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API)**I，该API中提供了两个方法：

1. [`Element.requestFullscreen()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/requestFullscreen):让指定元素进行全屏
2. [`Document.exitFullscreen()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/exitFullscreen)：退出全屏

但是这些`API`比较原始，使用起来没有这么方便，所以我们可以使用一个 **`vueuse`** 中的更加简便的API：**[useFullScreen](https://vueuse.nodejs.cn/core/useFullscreen/#component-usage)**

1. 利用 `useFullScreen` 生成` img `图片的全屏方法：

2. 将 `onImgFullScreen`绑定至全屏按钮点击事件：

   ```vue
   <template>
   <!-- :src="data.photo"   height：缩放比的高度-->
    <img
        v-lazy
        ref="imgTarget"  // 全屏元素
        class="w-full rounded bg-transparent"
        :src="data.photo"
        :style="{
         height: (width / data.photoWidth) * data.photoHeight + 'px'
       }"
      />
    <m-button
       class="absolute bottom-1.5 right-1.5 bg-zinc-100/70"
       type="info"
       size="small"
       icon="full"
       iconClass="fill-zinc-900 dark:fill-zinc-200"
        @click="onImgFullScreen"  // 事件绑定
     />
   </template>
   <script>
   import { useFullscreen, useElementBounding } from '@vueuse/core'
   ...
   const imgTarget = ref(null)
   /**
    * 生成全屏方法
    */
   const { enter: onImgFullScreen } = useFullscreen(imgTarget)
   
   </script>
   ```

### 12.7 构建floating基础布局

包含引导页和反馈功能

### 12.8 样式修正：处理难看的scrollBar

对于 tailwind 而言，默认没有提供 scrollBar 的样式类名，想要处理 scrollBar 的样式，那么需要安装单独的插件：**[tailwind-scrollbar](https://www.npmjs.com/package/tailwind-scrollbar)**

1. 安装插件：

   ```bash
   npm install --save-dev tailwind-scrollbar@1.3.1
   ```

2. 在` tailwind.config.js` 中注册该插件

   `plugins`: `[require('tailwind-scrollbar')]`

3. 在 tailwind.config.js 中，让 scrollbar 支持 dark 模式：

   ```js
   theme: {
       extend: {
           ...
           variants: {
           	scrollbar: ['dark']
         	}
       }
   }
   ```

`src\views\main\index.vue` 增加`div`的`css`代码

```vue
<template>
<!--固定引用写法-->
  <div
    class="...  scrollbar-thin scrollbar-thumb-transparent xl:scrollbar-thumb-zinc-200 xl:dark:scrollbar-thumb-zinc-900 scrollbar-track-transparent"
    ref="containerTarget"
  >
</template
```

`src\styles\index.scss`

```scss
// scrollbar 增加圆弧
::-webkit-scrollbar-thumb {
  border-radius: 10px;
}
```

### 12.9 功能引导解决方案

第三方的包： **[`driver.js`](https://www.npmjs.com/package/driver.js)** 

```bash
npm install --save driver.js@0.9.8
```

在 `src\views\layout\components\floating\index.vue` 中引入模块

```js
import Driver from 'driver.js'
import 'driver.js/dist/driver.min.css'
```

初始化 Driver:

```js
/**
 * 引导页处理
 */
let driver = null
onMounted(() => {
  driver = new Driver({
    // 禁止点击蒙版关闭
    allowClose: false,
    closeBtnText: '关闭',
    nextBtnText: '下一个',
    prevBtnText: '上一个'
  })
})

/**
 * 开始引导
 */
const onGuideClick = () => {
  driver.defineSteps(steps)
  driver.start()
}
```

```vue
<!-- 引导页 -->
    <div
      class="guide-start w-4 h-4 mb-1 bg-white dark:bg-zinc-900 border dark:border-0 border-zinc-200 rounded-full flex justify-center items-center cursor-pointer duration-200 group hover:shadow-lg"
      @click="onGuideClick"
    >
```

### 12.10 解决功能引导图标不显示的问题

背景挡住了图标问题：

`src\styles\index.scss`

```scss
// 解决引导图标覆盖问题，样式缺失引起的
.driver-fix-stacking {
  position: relative;
}
// 解决引导样式不对齐问题
.driver-navigation-btns {
  line-height: 0;
}
```

`src\views\layout\components\floating\index.vue`

```vue
<style lang="scss" scoped>
.driver-fix-stacking {
  position: fixed;
  z-index: 100004 !important;
}
</style>
```

### 12.11 总结

处理4个核心功能：

1. 文件下载
2. 通用组件：message 构建
3. 全屏处理
4. 引导处理

## 13 高阶路由过渡处理方案

### 13.2 `VueRouter`过渡动效可行性分析

```vue
<router-view v-slot="{Component}">
    <transition name="fade">
    	<component :is="Component"></component>
    </transition>
</router-view>
```

其中涉及到了三个组件：

1. router-view：路由出口
2. transition：动画组件,可以给任何元素和组件添加进入/离开的过渡效果
3. component：动态组件

由此可知，vue-router过度动效产生的关键就是 transition 动画组件

那么同时我们知道 transition 而言，它能够产生动画的关键，其实就是内部元素 component 的动态组件切换。

但是这样的切换一定是基于整个**页面组件**的。也就是说如果我们利用这种过度动效，那么一定是：**从home页面到detail页面的整体页面**组件的切换，所以是 **无法** 实现我们期望的这种路由过度效果的。需要另想办法。

### 13.3 主动介入浏览器堆栈管理，分析可行性方案

上一节分析，通过vue-router的国度动效是无法实现砸门期望的路由切换效果的。

要搞清楚**什么是路由的跳转?**

所谓路由跳转无非指的是两部分：

1. 浏览器的 url 发生了改变
2. 浏览器中展示的页面组件发生了改变。

只要满足这两点，我们就认为 **路径进行了跳转**

所以说，我们换个思路，**不去进行真实的路由跳转，**而是**先修改浏览器的URL**，**在切换展示的页面（以组件的形式覆盖整个浏览器的可视区域）**

具体问题就变成了：

1. **如何让浏览器的 `url` 发生变化，但是不跳转页面。**
2. **如何让一个新的组件以包含动画的形式进行展示**

想要完成第一个功能，可以利用 [**`History.pushState()`**](https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState)方法。`history.pushState(state, title[, url])`,浏览器不发生跳转

而第二个功能可以使用 **`GSAP`** 这个动画库来进行实现。

### 13.4 主动介入浏览器堆栈管理

`src\views\main\components\list\item.vue` 模板子组件

```vue
...
<div
  class="relative w-full rounded cursor-zoom-in group"
  :style="{
   	backgroundColor: randomRGB()
   }"
    @click="onToPinsClick" // 子组件模板添加点击事件
 >
  ...
<script>
const props = defineProps({
  data: {
    type: Object,
    required: true
  },
  width: {
    type: Number,
    default: 0
  }
})
const emits = defineEmits(['click'])
/**
 * 进入详情点击事件,传递参数
 */
const onToPinsClick = () => {
  emits('click', {
    id: props.data.id,
    localtion: imgContainerCenter.value
  })
}

</script> 
```

`src\views\main\components\list\index.vue` 父组件引用子组件

```vue
...
<template v-slot="{ item, width }">
   <itemVue :data="item" :width="width" @click="onToPins" />  // 父组件监听子组件的click事件
</template>
...
<script>
// 控制 pins 展示
const isVisiblePins = ref(false)
// 当前选中的 pins 属性
const currentPins = ref({})
/**
 * 进入 pins
 */
const onToPins = (item) => {
  // 心里是记录条目的URL，请注意，浏览器不会再调用pushState()之后尝试加载此URL
  history.pushState(null, null, `/pins/${item.id}`)
  currentPins.value = item
  isVisiblePins.value = true
}
</script>

```

完成往浏览器的堆栈之中插入了 URL 地址,可以点击后退。

### 13.5 基于GSAP实现高阶路由过渡动画分析

当 `url` 发生改变之后，我们就只处理动画就可以了。

**[`GSAP 动画官网`](https://gsap.com/)**  https://gsap.com/  文档中心 https://gsap.com/docs/v3/GSAP/

动画的处理我们依赖 [**`GSAP`**](https://github.com/greensock/GSAP) 进行实现。对于 `GSAP`而言，主要依赖两个方法：

1. [`gasp.set()`](https://gsap.com/docs/v3/GSAP/gsap.set()) : 在动画开始前，表示设置动画开始前的元素属性
2. [`gsap.to()`](https://gsap.com/docs/v3/GSAP/gsap.to()): 表示 最终元素展示的状态

GSAP 会基于 set 和 to 的状态，来自动执行中间的补间动画

所以，我们只需要：

1. 创建一个对应的组件，使用 `transition` 进行包裹
2. 计算出 set 时，组件元素对应的样式属性
3. 计算出 to 时，组件元素对应的样式属性

然后就可以由 `GSAP `自动实现对应的补间动画了。

### 13.6 基于GSAP实现高阶路由过渡动画处理

`src\views\pins\index.vue`

```vue
<template>
  <div class="w-full h-full bg-zinc-200 dark:bg-zinc-800">
    <pins-vue :id="$route.params.id" />
  </div>
</template>

<script setup>
import pinsVue from './components/pins.vue'
</script>
```

`src\views\pins\components\pins.vue`

```vue
<template>
  <div
    class="fixed left-0 top-0 w-screen h-screen z-20 backdrop-blur-4xl bg-white dark:bg-zinc-800 pb-2 overflow-y-auto xl:p-2 xl:bg-transparent"
  >
    <!-- 移动端下展示 navbar -->
    <m-navbar
      v-if="isMobileTerminal"
      sticky
      @clickLeft="onPop"
      @clickRight="onPop"
    >
      {{ pexelData.title }}
      <template #right>
        <m-svg-icon
          name="share"
          class="w-3 h-3"
          fillClass="fill-zinc-900 dark:fill-zinc-200"
        ></m-svg-icon>
      </template>
    </m-navbar>
    <!-- pc 端下展示关闭图标 -->
    <m-svg-icon
      v-else
      name="close"
      class="w-3 h-3 ml-1 p-0.5 cursor-pointer duration-200 rounded-sm hover:bg-zinc-100 absolute right-2 top-2"
      fillClass="fill-zinc-400"
      @click="onPop"
    ></m-svg-icon>

    <div class="xl:w-[80%] xl:h-full xl:mx-auto xl:rounded-lg xl:flex">
      <img
        class="w-screen mb-2 xl:w-3/5 xl:h-full xl:rounded-tl-lg xl:rounded-bl-lg"
        :src="pexelData.photo"
      />
      <div
        class="xl:w-2/5 xl:h-full xl:bg-white xl:dark:bg-zinc-900 xl:rounded-tr-lg xl:rounded-br-lg xl:p-3"
      >
        <div v-if="!isMobileTerminal" class="flex justify-between mb-2">
          <m-svg-icon
            name="share"
            class="w-4 h-4 p-1 cursor-pointer hover:bg-zinc-200 dark:hover:bg-zinc-800 duration-300 rounded"
            fillClass="fill-zinc-900 dark:fill-zinc-200"
          ></m-svg-icon>

          <m-button
            class=""
            type="info"
            icon="heart"
            iconClass="fill-zinc-900 dark:fill-zinc-200"
          />
        </div>
        <!-- 标题 -->
        <p
          class="text-base text-zinc-900 dark:text-zinc-200 ml-1 font-bold xl:text-xl xl:mb-5"
        >
          {{ pexelData.title }}
        </p>
        <!-- 作者 -->
        <div class="flex items-center mt-1 px-1">
          <img
            v-lazy
            class="h-3 w-3 rounded-full"
            :src="pexelData.avatar"
            alt=""
          />
          <span class="text-base text-zinc-900 dark:text-zinc-200 ml-1">{{
            pexelData.author
          }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { getPexelsFromId } from '@/api/pexels'
import { isMobileTerminal } from '@/utils/flexible'
import { useRouter } from 'vue-router'
import { useStore } from 'vuex'

const props = defineProps({
  id: {
    type: String,
    required: true
  }
})

const pexelData = ref({})
/**
 * 获取详情数据
 */
const getPexelData = async () => {
  const data = await getPexelsFromId(props.id)
  pexelData.value = data
}
getPexelData()

/**
 * 关闭按钮处理事件
 */
const router = useRouter()
const store = useStore()
const onPop = () => {
  // 配置跳转方式
  store.commit('app/changeRouterType', 'back')
  router.back()
}
</script>

<style lang="scss" scoped></style>

```

`src\views\main\components\list\index.vue`

```vue
...
<!-- 大图详情处理 -->
  	<transition
      :css="false"
      @before-enter="beforeEnter"
      @enter="enter"
      @leave="leave"
    >
      <pins-vue v-if="isVisiblePins" :id="currentPins.id" />
    </transition>
...
<script>
import { useEventListener } from '@vueuse/core'
import pinsVue from '@/views/pins/components/pins.vue'
import gsap from 'gsap'
// 控制 pins 展示
const isVisiblePins = ref(false)
// 当前选中的 pins 属性 包含图片中心位置坐标
const currentPins = ref({})
/**
 * 进入 pins
 */
const onToPins = (item) => {
  // 心里是记录条目的URL，请注意，浏览器不会再调用pushState()之后尝试加载此URL
  // item 的数据来源于组件的click函数参数 { id: props.data.id, localtion: imgContainerCenter.value }

  history.pushState(null, null, `/pins/${item.id}`)
  currentPins.value = item
  isVisiblePins.value = true
}
/**
 * 监听浏览器后退按钮事件 popstate 后退
 */
useEventListener(window, 'popstate', () => {
  isVisiblePins.value = false
})

/**
 * 进入动画开始前
 */
const beforeEnter = (el) => {
  gsap.set(el, {
    scaleX: 0,
    scaleY: 0,
    transformOrigin: '0 0',
    translateX: currentPins.value.localtion?.translateX,
    translateY: currentPins.value.localtion?.translateY,
    opacity: 0
  })
}
/**
 * 进入动画执行中
 */
const enter = (el, done) => {
  gsap.to(el, {
    duration: 0.3,
    scaleX: 1,
    scaleY: 1,
    opacity: 1,
    translateX: 0,
    translateY: 0,
    onComplete: done
  })
}
/**
 * 离开动画执行中
 */
const leave = (el, done) => {
  gsap.to(el, {
    duration: 0.3,
    scaleX: 0,
    scaleY: 0,
    x: currentPins.value.localtion?.translateX,
    y: currentPins.value.localtion?.translateY,
    opacity: 0
  })
}
</script>
```

点击的时候会从当前图片的中心位置扩大到全屏，关闭的时候，会缩小到原来的中心位置消失。

`src\views\main\components\list\item.vue`

```js
import { useFullscreen, useElementBounding } from '@vueuse/core'
const imgTarget = ref(null)
const {
  x: imgContainerX,
  y: imgContainerY,
  width: imgContainerWidth,
  height: imgContainerHeight
} = useElementBounding(imgTarget)  // 获得响应式的数据
const imgContainerCenter = computed(() => {
  return {
    translateX: parseInt(imgContainerX.value + imgContainerWidth.value / 2),
    translateY: parseInt(imgContainerY.value + imgContainerHeight.value / 2)
  }
})
```

### 13.7 通用组件：详情页navbar构建方案分析

pins 的页面样式可以同时应用到  PC段 和 移动端。然而在移动端中，则会展示对应的 navbar 的内容。

对于 navbar 而言：

1. 它分为 **左、中、右** 三大部分，三个部分都可以通过插槽进行指定
2. **左、右**两边插槽看样子定义点击事件
3. 同时 `navbar` 有时候会存在**吸顶的效果**，所以我们最好还可以通过一个 props 指定对应的吸顶展示

### 13.9 通用组件：构建navbar

`src\libs\navbar\index.vue`

```vue
<template>
  <div
    class="w-full h-5 border-b flex items-center z-10 bg-white dark:bg-zinc-800 border-b-zinc-200 dark:border-b-zinc-700"
    :class="[sticky ? 'sticky top-0 left-0' : 'relative']"
  >
    <!-- 左 -->
    <div
      class="h-full w-5 absolute left-0 flex items-center justify-center"
      @click="onClickLeft"
    >
      <slot name="left">
        <m-svg-icon
          name="back"
          class="w-2 h-2"
          fillClass="fill-zinc-900 dark:fill-zinc-200"
        />
      </slot>
    </div>
    <!-- 中 -->
    <div
      class="h-full flex items-center justify-center m-auto font-bold text-base text-zinc-900 dark:text-zinc-200"
    >
      <slot></slot>
    </div>
    <!-- 右 -->
    <div
      class="h-full w-5 absolute right-0 flex items-center justify-center"
      @click="onClickRight"
    >
      <slot name="right" />
    </div>
  </div>
</template>
<script setup>
import { useRouter } from 'vue-router'

const props = defineProps({
  // 左边按钮的点击
  clickLeft: {
    type: Function
  },
  // 右边按钮的点击
  clickRight: {
    type: Function
  },
  // 是否吸顶
  sticky: {
    type: Boolean
  }
})
const router = useRouter()
/**
 * 左侧按钮点击事件
 */
const onClickLeft = () => {
  if (props.clickLeft) {
    props.clickLeft()
    return
  }
  router.back()
}

/**
 * 右侧按钮点击事件
 */
const onClickRight = () => {
  if (props.clickRight) {
    props.clickRight()
  }
}
</script>

<style lang="scss" scoped></style>

```

### 13.10 基于navbar处理响应式的`pins`页面

根据pins id 走接口获取指定数据

### 13.11 处理刷新空白问题

PC端自动刷新页面，浏览器会白屏。因为浏览器会重新加载页面，新的`url`没有对应的路由。给他制定路由就好了

`src\views\pins\components\pins.vue`

```vue
<template>
  <div class="w-full h-full bg-zinc-200 dark:bg-zinc-800">
    <pins-vue :id="$route.params.id" />
  </div>
</template>

<script setup>
import pinsVue from './components/pins.vue'
</script>
```

添加PC端的路由：

`src\router\modules\pc-routes.js`

```js
{
   path: '/pins/:id',
   name: 'pins',
   component: () => import('@/views/pins/index.vue')
},
```

## 14 人类行为验证处理方案

### 14.2 构建登录模块基础UI结构

### 14.3 表单校验实现原理与方案分析

**表单校验的实现原理**

1. 在某一个时机下（拾取焦点，内容变化）
2. 检查表单元素中的 value 是否符合某个条件（校验条件）
3. 如果不符合，则给出对应的提示

根据以上描述，我们所需要关注的，其实就是三点内容：

1. 监听表单元素的对应时机
2. 检查内容是否匹配校验条件
3. 根据检查结果，展示对应提示

**自定义表单校验方案分析**

那么根据以上原理描述，如果我们想要自定义一套表单校验的功能逻辑，是不是就比较简单了：

1. 创建对应的 field 输入框组件
2. 该组件中，包含两个元素:
   1. input 输入框
   2. span 表示错误提示

3. 监听 input 输入框的 blur 失去焦点 事件
4. 根据 input 的 value 判断是否满足一个或多个指定的条件(比如:是否为空)
5. 如果不满足，则展示 span 标签，表示错误提示消息

**课程中的方案实现**

根据以上描述，我们确实可以实现一个基础的表单校验，但是这样的表单校验组件，很难具 普适 性，因为实际开发中，表单校验的场景多种多样，比如:**国际化处理。** 

所以说，把它抽离成一个 **通用组件** 意义并不大，所以咱们在课程中，就不会专门去实现这样的一个组件，而是会采用种更加普适的方式。

这个方式就是：[**`vee-validate`**](https://vee-validate.logaretm.com/v4/tutorials/basics/)

[**`vee-validata`**](https://vee-validate.logaretm.com/v4/tutorials/basics/) 是一个 vue 中专门做表单校验的库，该库更加具有 **普适** 性，也更加适合大家在实际开发中的使用

### 14.4 基于vee-validata实现普适的表单校验

1. 安装最新的 vee-validate@4.5.10 

   ```bash
   npm install --save vee-validate@4.5.10
   ```

2. `vee-validate` 中提供了非常详细的基础使用流程：[**点击这里**](https://vee-validate.logaretm.com/v4/tutorials/basics/)
3. 在这一套流程中，设计到了三个组件，分别为：
   1. `Form`：表单
   2. `Field`：输入框
   3. `ErrorMessage`：错误提示

4. 接下来就使用这三个组件，代替咋们默认的表单域，期中每个单独的表单域都具备一个 name，该 name 为对应 **表单域和错误提示**

`src\views\login-register\login\index.vue`

```vue
<template>
...
<vee-form @submit="onLoginHandler"> // 所有表单校验通过才会执行此方法
    ...
    <vee-field 
        name="username" 
        :rules="validateUsername" /> // 校验规则
    <vee-error-message name="username" />  // name 要一致，对应错误提示
    <vee-field 
        name="password" 
        :rules="validatePassword" />
    <vee-error-message name="password" /> 
    
</vee-form>
...
</template>
<script>
// 导入三个组件并重命名，防止关键字冲突
import {
  Form as VeeForm,
  Field as VeeField,
  ErrorMessage as VeeErrorMessage
} from 'vee-validate'
// 导入表单字段校验规则
import { validateUsername, validatePassword } from '../validate' 
</script>

```

注册和登录的校验规则:

`src\views\login-register\validate.js`

```js
/**
 *
 * @param {*} value 输入的内容
 * @returns true 表示表单校验通过,String 表示表单校验未通过，为错误提示消息
 */
export const validateUsername = (value) => {
  if (!value) {
    return '用户名为必填的'
  }

  if (value.length < 3 || value.length > 12) {
    return '用户名应该在 3-12 位之间'
  }
  return true
}

/**
 * 密码的表单校验
 */
export const validatePassword = (value) => {
  if (!value) {
    return '密码为必填的'
  }

  if (value.length < 6 || value.length > 12) {
    return '密码应该在 6-12 位之间'
  }
  return true
}

/**
 * 确认密码的表单校验
 */
export const validateConfirmPassword = (value, password) => {
  if (value !== password[0]) {
    return '两次密码输入必须一致'
  }
  return true
}
```

### 14.5 什么是人类行为验证？它的目的、实现原理、构建方案分别是什么

人类行为验证的目的就是：明确当前的操作者是人完成的，而非机器。

**我们应该如何在项目中用它**

1. 收费平台，年费在几万到几十万不等，有专门的技术人员帮助对接
   1. 极验
   2. 网易易盾
   3. ...

2. 免费开源，验证的精准度，需要看服务端的能力
   1. `gitee` 开源的： [**`SliderCaptcha`**](https://gitee.com/LongbowEnterprise/SliderCaptcha)

这里主要使用开源的 `SliderCaptcha`  https://gitee.com/LongbowEnterprise/SliderCaptcha

### 14.7 构建人类行为验证模块

资源下载地址

https://gitee.com/LongbowEnterprise/SliderCaptcha/tree/master/src/disk

`js`: `longbow.slidercaptcha.min.js`

`css`: `slidercaptcha.min.css`

单独模块：`src\views\login-register\login\slider-captcha.vue`

```vue
<template>
  <div
    class="fixed top-[20%] left-[50%] translate-x-[-50%] w-[340px] h-[270px] text-sm bg-white dark:bg-zinc-800 rounded border border-zinc-200 dark:border-zinc-900 shadow-3xl"
  >
    <div class="flex items-center h-5 text-left px-1 mb-1">
      <span class="flex-grow dark:text-zinc-200">请完成安全验证</span>
      <m-svg-icon
        name="refresh"
        fillClass="fill-zinc-900 dark:fill-zinc-200"
        class="w-3 h-3 p-0.5 rounded-sm duration-300 cursor-pointer hover:bg-zinc-200 dark:hover:bg-zinc-900"
        @click="onReset"
      ></m-svg-icon>
      <m-svg-icon
        name="close"
        fillClass="fill-zinc-900 dark:fill-zinc-200"
        class="ml-2 w-3 h-3 p-0.5 rounded-sm duration-300 cursor-pointer hover:bg-zinc-200 dark:hover:bg-zinc-900"
        @click="onClose"
      ></m-svg-icon>
    </div>
    <div id="captcha"></div>
  </div>
</template>

<script>
const EMITS_CLOSE = 'close'
const EMITS_SUCCESS = 'success'
</script>

<script setup>
import '@/vendor/SliderCaptcha/slidercaptcha.min.css'
import '@/vendor/SliderCaptcha/longbow.slidercaptcha.min.js'
import { getCaptcha } from '@/api/sys'
import { onMounted } from 'vue'

const emits = defineEmits([EMITS_CLOSE, EMITS_SUCCESS])

let captcha = null
onMounted(() => {
  captcha = sliderCaptcha({
    // 渲染位置
    id: 'captcha',
    // 用户拼图成功之后的回调
    async onSuccess(arr) {
      const res = await getCaptcha({
        behavior: arr
      })
      if (res) {
        emits(EMITS_SUCCESS)
      }
    },
    // 用户拼图失败之后的回调
    onFail() {
      console.log('onFail')
    },
    // 默认的验证方法，咱们不在此处进行验证，而是选择在用户拼图成功之后进行验证，所以此处永远返回为 true
    verify() {
      return true
    }
  })
})

/**
 * 重置
 */
const onReset = () => {
  captcha.reset()
}

/**
 * 关闭
 */
const onClose = () => {
  emits(EMITS_CLOSE)
}
</script>
```

### 14.11 token超时处理

通常情况下 token 具备时效性，在本课程中， token 失效后，服务端会返回 401，表示需要重新登录

那么对应的操作就可以在**`axios`的响应拦截器中进行**

`src\utils\request.js`

```js
// 响应拦截器
// 服务端返回数据之前，前端 .then之前被调用
service.interceptors.response.use(
  (response) => {
    const { success, message, data } = response.data
    //   要根据success的成功与否决定下面的操作
    if (success) {
      return data
    } else {
      $message('warn', message)
      // TODO：业务错误
      return Promise.reject(new Error(message))
    }
  },
  (error) => {
    // 处理 token 超时问题
    if (
      error.response &&
      error.response.data &&
      error.response.data.code === 401
    ) {
      // TODO: token超时
      store.dispatch('user/logout')
    }
    $message('error', error.response.data.message)
    // TODO: 提示错误消息
    return Promise.reject(error)
  }
)
```

## 15 图片裁剪与上传处理方案

### 15.3 通用组件：input构建方案

通用组件：`src\libs\input\index.vue`

```vue
<template>
  <div class="relative">
    <input
      v-if="type === TYPE_TEXT"
      class="border-gray-200 dark:border-zinc-600 dark:bg-zinc-800 duration-100 dark:text-zinc-400 border-[1px] outline-0 py-0.5 px-1 text-sm rounded-sm focus:border-blue-400 w-full"
      type="text"
      v-model="text"
      :maxlength="max"
    />
    <textarea
      v-if="type === TYPE_TEXTAREA"
      v-model="text"
      :maxlength="max"
      rows="5"
      class="border-gray-200 dark:border-zinc-600 dark:bg-zinc-800 duration-100 dark:text-zinc-400 border-[1px] outline-0 py-0.5 px-1 text-sm rounded-sm focus:border-blue-400 w-full"
    ></textarea>
    <span
      v-if="max"
      class="absolute right-1 bottom-0.5 text-zinc-400 text-xs"
      :class="{ 'text-red-700': currentNumber === parseInt(max) }"
      >{{ currentNumber }} / {{ max }}</span
    >
  </div>
</template>

<script>
const TYPE_TEXT = 'text'
const TYPE_TEXTAREA = 'textarea'
</script>

<script setup>
import { useVModel } from '@vueuse/core'
import { computed } from 'vue'

const props = defineProps({
  // v-model双向绑定
  modelValue: {
    required: true,
    type: String
  },
  // 单行还是多行
  type: {
    type: String,
    default: TYPE_TEXT,
    validator(value) {
      const arr = [TYPE_TEXT, TYPE_TEXTAREA]
      const result = arr.includes(value)
      if (!result) {
        throw new Error(`type 的值必须在可选范围内 [${arr.join('、')}]`)
      }
      return result
    }
  },
  // 最大字符数
  max: {
    type: [String, Number]
  }
})

// 虽然不使用 ，但是vue3要规范事件声明
defineEmits(['update:modelValue'])

// 输入的字符
const text = useVModel(props)

// 输入的字符数
const currentNumber = computed(() => {
  return text.value?.length
})
</script>

<style lang="scss" scoped></style>
```

### 15.8 头像修改方案流程分析

1. PC端：
   1. 点击更换头像
   2. 选择对应文件
   3. 通过 Dialog 展示图片裁剪
   4. 裁剪后图片上传
   5. 功能完成

2. 移动端：
   1. 点击更换头像
   2. 选择对应文件
   3. 通过popup展示图片裁剪
   4. 裁剪后图片上传
   5. 功能完成

由此发现，两者之间需要通过不同的组件进行裁剪展示。

所以会偶流程为：

1. 通过组件：Dialog
2. 处理图片裁剪
3. 处理裁剪后上传

### 15.9 通用组件：Dialog构建方案分析

可以参考 confirm 组件的构建过程：

构建方案非常相似，唯二不同的地方是：

1. Dialog 无需通过方法调用的形式展示
2. Dialog 的内容区可以渲染任意的内容

排除这两点，其余与confirm完全相同

### 15.10 通用组件：Dialog构建方案

文件路径：`src\libs\dialog\index.vue`

```vue
<template>
  <div>
    <!-- 蒙版 -->
    <transition name="fade">
      <div
        v-if="isVisable"
        @click="close"
        class="w-screen h-screen bg-zinc-900/80 z-40 fixed top-0 left-0"
      ></div>
    </transition>
    <!-- 内容 -->
    <transition name="up">
      <div
        v-if="isVisable"
        class="max-w-[80%] max-h-[80%] overflow-auto fixed top-[10%] left-[50%] translate-x-[-50%] z-50 px-2 py-1.5 rounded-sm border dark:border-zinc-600 cursor-pointer bg-white dark:bg-zinc-800 xl:min-w-[35%]"
      >
        <!-- 标题 -->
        <div
          class="text-lg font-bold text-zinc-900 dark:text-zinc-200 mb-2"
          v-if="title"
        >
          {{ title }}
        </div>
        <!-- 内容 -->
        <div class="text-base text-zinc-900 dark:text-zinc-200 mb-2">
          <slot />
        </div>
        <!-- 按钮 -->
        <div class="flex justify-end" v-if="cancelHandler || confirmHandler">
          <m-button type="info" class="mr-2" @click="onCancelClick">{{
            cancelText
          }}</m-button>
          <m-button type="primary" @click="onConfirmClick">{{
            confirmText
          }}</m-button>
        </div>
      </div>
    </transition>
  </div>
</template>

<script setup>
import { useVModel } from '@vueuse/core'

const props = defineProps({
  // 控制开关
  modelValue: {
    type: Boolean,
    required: true
  },
  // 标题,非必传
  title: {
    type: String
  },
  // 取消按钮文本
  cancelText: {
    type: String,
    default: '取消'
  },
  // 确定按钮文本
  confirmText: {
    type: String,
    default: '确定'
  },
  // 取消按钮点击事件
  cancelHandler: {
    type: Function
  },
  // 确定按钮点击事件
  confirmHandler: {
    type: Function
  },
  // 关闭的回调
  close: {
    type: Function
  }
})

defineEmits(['update:modelValue'])

// 控制显示开关的双向数据绑定，默认取 modelValue 的值
const isVisable = useVModel(props)

/**
 * 取消按钮点击事件
 */
const onCancelClick = () => {
  if (props.cancelHandler) {
    props.cancelHandler()
  }
  close()
}

/**
 * 确定按钮点击事件
 */
const onConfirmClick = () => {
  if (props.confirmHandler) {
    props.confirmHandler()
  }
  close()
}

const close = () => {
  isVisable.value = false
  if (props.close) {
    props.close()
  }
}
</script>

<style lang="scss" scoped>
.fade-enter-active,
.fade-leave-active {
  transition: all 0.3s;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.up-enter-active,
.up-leave-active {
  transition: all 0.3s;
}

.up-enter-from,
.up-leave-to {
  opacity: 0;
  transform: translate3d(-50%, 100px, 0);
}
</style>
```

### 15.11 应用Dialog展示头像

裁剪头像封装成一个同一个通用组件：

```vue
<template>
  <div class="overflow-auto relative flex flex-col items-center">
    <m-svg-icon
      v-if="isMobileTerminal"
      name="close"
      class="w-3 h-3 p-0.5 m-1 ml-auto"
      fillClass="fill-zinc-900 dark:fill-zinc-200 "
      @click="close"
    ></m-svg-icon>

    <img class="" ref="imageTarget" :src="blob" />

    <m-button
      class="mt-4 w-[80%] xl:w-1/2"
      :loading="loading"
      @click="onConfirmClick"
    >
      确定
    </m-button>
  </div>
</template>

<script>
const EMITS_CLOSE = 'close'

// 移动端配置对象
const mobileOptions = {
  // 将裁剪框限制在画布的大小
  viewMode: 1,
  // 移动画布，裁剪框不动
  dragMode: 'move',
  // 裁剪框固定纵横比：1:1
  aspectRatio: 1,
  // 裁剪框不可移动
  cropBoxMovable: false,
  // 不可调整裁剪框大小
  cropBoxResizable: false
}

// PC 端配置对象
const pcOptions = {
  // 裁剪框固定纵横比：1:1
  aspectRatio: 1
}
</script>

<script setup>
import { isMobileTerminal } from '@/utils/flexible'
import Cropper from 'cropperjs'
import 'cropperjs/dist/cropper.css'
import { ref, onMounted } from 'vue'
import { getOSSClient } from '@/utils/sts'
import { message } from '@/libs'
import { useStore } from 'vuex'
import { putProfile } from '@/api/sys'

defineProps({
  blob: {
    type: String,
    required: true
  }
})

const emits = defineEmits([EMITS_CLOSE])

/**
 * 图片裁剪处理
 */
const imageTarget = ref(null)
let cropper = null
onMounted(() => {
  /**
   * 接收两个参数：
   * 1. 需要裁剪的图片 DOM
   * 2. options 配置对象
   */
  cropper = new Cropper(
    imageTarget.value,
    isMobileTerminal.value ? mobileOptions : pcOptions
  )
})

/**
 * 确定按钮点击事件
 */
const loading = ref(false)
const onConfirmClick = () => {
  loading.value = true
  // 获取裁剪后的图片
  cropper.getCroppedCanvas().toBlob((blob) => {
    // 裁剪后的 blob 地址
    // console.log(URL.createObjectURL(blob))
    putObjectToOSS(blob)
  })
}

/**
 * 进行 OSS 上传
 */
let ossClient = null
let store = useStore()
const putObjectToOSS = async (file) => {
  if (!ossClient) {
    ossClient = await getOSSClient()
  }
  try {
    // 因为当前凭证只具备 images 文件夹下的访问权限，所以图片需要上传到 images/xxx.xx 。否则你将得到一个 《AccessDeniedError: You have no right to access this object because of bucket acl.》 的错误
    const fileTypeArr = file.type.split('/')
    const fileName = `${store.getters.userInfo.username}/${Date.now()}.${
      fileTypeArr[fileTypeArr.length - 1]
    }`
    // 文件存放路径，文件
    const res = await ossClient.put(`images/${fileName}`, file)
    // 通知服务器
    onChangeProfile(res.url)
  } catch (e) {
    message('error', e)
  }
}

/**
 * 上传新头像到服务器
 */
const onChangeProfile = async (avatar) => {
  // 更新本地数据
  store.commit('user/setUserInfo', {
    ...store.getters.userInfo,
    avatar
  })
  // 更新服务器数据
  await putProfile(store.getters.userInfo)
  // 通知用户
  message('success', '用户头像修改成功')
  // 关闭 loading
  loading.value = false
  // 关闭 dialog
  close()
}

/**
 * 关闭事件
 */
const close = () => {
  emits(EMITS_CLOSE)
}
</script>

<style lang="scss" scoped></style>
```

**个人信息** 的选择头像里面修改：`src\views\profile\index.vue`

```vue
<template>
  <div
    class="h-full bg-zinc-200 dark:bg-zinc-800 duration-400 overflow-auto xl:pt-1"
  >
    <div
      class="relative max-w-screen-lg mx-auto bg-white dark:bg-zinc-900 duration-400 xl:rounded-sm xl:border-zinc-200 xl:dark:border-zinc-600 xl:border-[1px] xl:px-4 xl:py-2"
    >
      <!-- 移动端 navbar -->
      <m-navbar sticky v-if="isMobileTerminal" :clickLeft="onNavbarLeftClick">
        个人资料
      </m-navbar>
      <!-- pc 端 -->
      <div v-else class="text-lg font-bold text-center mb-4 dark:text-zinc-300">
        个人资料
      </div>
      <div class="h-full w-full px-1 pb-4 text-sm mt-2 xl:w-2/3 xl:pb-0">
        <!-- 头像 -->
        <div class="py-1 xl:absolute xl:right-[16%] xl:text-center">
          <span
            class="w-8 inline-block mb-2 font-bold text-sm dark:text-zinc-300 xl:block xl:mx-auto"
            >我的头像</span
          >
          <!-- 头像部分 -->
          <div
            class="relative w-[80px] h-[80px] group xl:cursor-pointer xl:left-[50%] xl:translate-x-[-50%]"
            @click="onAvatarClick"
          >
            <img
              v-lazy
              :src="$store.getters.userInfo.avatar"
              alt=""
              class="rounded-[50%] w-full h-full xl:inline-block"
            />
            <div
              class="absolute top-0 rounded-[50%] w-full h-full bg-[rgba(0,0,0,.4)] hidden xl:group-hover:block"
            >
              <m-svg-icon
                name="change-header-image"
                class="w-2 h-2 m-auto mt-2"
              ></m-svg-icon>
              <div
                class="text-xs text-white dark:text-zinc-300 scale-90 mt-0.5"
              >
                点击更换头像
              </div>
            </div>
          </div>
          <!-- 隐藏域 -->
          <input
            v-show="false"
            ref="inputFileTarget"
            type="file"
            accept=".png, .jpeg, .jpg, .gif"
            @change="onSelectImgHandler"
          />
          <p class="mt-1 text-zinc-500 dark:text-zinc-400 text-xs xl:w-10">
            支持 jpg、png、jpeg 格式大小 5M 以内的图片
          </p>
        </div>
        <!-- 用户名 -->
        <div class="py-1 xl:flex xl:items-center xl:my-1">
          <span class="w-8 block mb-1 font-bold dark:text-zinc-300 xl:mb-0"
            >用户名</span
          >
          <m-input
            v-model="userInfo.nickname"
            class="w-full"
            type="text"
            max="20"
          ></m-input>
        </div>
        <!-- 职位 -->
        <div class="py-1 xl:flex xl:items-center xl:my-1">
          <span class="w-8 block mb-1 font-bold dark:text-zinc-300 xl:mb-0"
            >职位</span
          >
          <m-input
            v-model="userInfo.title"
            class="w-full"
            type="text"
          ></m-input>
        </div>
        <!-- 公司 -->
        <div class="py-1 xl:flex xl:items-center xl:my-1">
          <span class="w-8 block mb-1 font-bold dark:text-zinc-300 xl:mb-0"
            >公司</span
          >
          <m-input
            v-model="userInfo.company"
            class="w-full"
            type="text"
          ></m-input>
        </div>
        <!-- 个人主页 -->
        <div class="py-1 xl:flex xl:items-center xl:my-1">
          <span class="w-8 block mb-1 font-bold dark:text-zinc-300 xl:mb-0"
            >个人主页</span
          >
          <m-input
            v-model="userInfo.homePage"
            class="w-full"
            type="text"
          ></m-input>
        </div>
        <!-- 个人介绍 -->
        <div class="py-1 xl:flex xl:my-1">
          <span class="w-8 block mb-1 font-bold dark:text-zinc-300 xl:mb-0"
            >个人介绍</span
          >
          <m-input
            v-model="userInfo.introduction"
            class="w-full"
            type="textarea"
            max="50"
          ></m-input>
        </div>
        <!-- 保存修改 -->
        <m-button
          class="w-full mt-2 mb-4 dark:text-zinc-300 dark:bg-zinc-800 xl:w-[160px] xl:ml-[50%] xl:translate-x-[-50%]"
          :loading="loading"
          @click="onChangeProfile"
          >保存修改</m-button
        >
        <!-- 移动端退出登录 -->
        <m-button
          v-if="isMobileTerminal"
          class="w-full dark:text-zinc-300 dark:bg-zinc-800 xl:w-[160px] xl:ml-[50%] xl:translate-x-[-50%]"
          @click="onLogoutClick"
        >
          退出登录
        </m-button>
      </div>
    </div>

    <!-- PC 端 -->
    <m-dialog v-if="!isMobileTerminal" v-model="isDialogVisible">
      <change-avatar-vue
        :blob="currentBolb"
        @close="isDialogVisible = false"
      ></change-avatar-vue>
    </m-dialog>
    <!-- 移动端 -->
    <m-popup
      v-else
      :class="{ 'h-screen': isDialogVisible }"
      v-model="isDialogVisible"
    >
      <change-avatar-vue
        :blob="currentBolb"
        @close="isDialogVisible = false"
      ></change-avatar-vue>
    </m-popup>
  </div>
</template>

<script>
export default {
  name: 'profile'
}
</script>

<script setup>
import { isMobileTerminal } from '@/utils/flexible'
import { putProfile } from '@/api/sys'
import { message, confirm } from '@/libs'
import { useRouter } from 'vue-router'
import { useStore } from 'vuex'
import { ref, watch } from 'vue'
import changeAvatarVue from './components/change-avatar.vue'

const store = useStore()
const router = useRouter()

// 隐藏域
const inputFileTarget = ref(null)
// 头像 dialog 展示
const isDialogVisible = ref(false)
// 选中的图片
const currentBolb = ref('')
/**
 * 更换头像点击事件
 */
const onAvatarClick = () => {
  // 调用隐藏的 onSelectImgHandler 点击事件
  inputFileTarget.value.click()
}

/**
 * 头像选择之后的回调
 */
const onSelectImgHandler = () => {
  // 获取选中的文件
  const imgFile = inputFileTarget.value.files[0]
  // 生成 blob 类文件对象
  const blob = URL.createObjectURL(imgFile)
  // 获取选中的图片，是一个连接浏览器可以打开
  // blob:http://....
  currentBolb.value = blob
  // 展示 Dialog
  isDialogVisible.value = true
}

/**
 * 监听 dialog 关闭
 */
watch(isDialogVisible, (val) => {
  if (!val) {
    // 防止 change 不重复触发
    // 当两次选择同一个文件，change的回调不会被再次触发
    // 想要解决这个问题，就只需要每次选择的图片不再被使用之后，清空掉 inputFileTarget 的 value
    inputFileTarget.value.value = null
  }
})

/**
 * 数据本地的双向同步
 */
const userInfo = ref(store.getters.userInfo)
// const changeStoreUserInfo = (key, value) => {
//   store.commit('user/setUserInfo', {
//     ...store.getters.userInfo,
//     [key]: value
//   })
// }

/**
 * 修改个人信息
 */
const loading = ref(false)
const onChangeProfile = async () => {
  loading.value = true
  await putProfile(userInfo.value)
  message('success', '用户信息修改成功')
  // 更新 vuex
  store.commit('user/setUserInfo', userInfo.value)
  loading.value = false
}

/**
 * 移动端后退处理
 */
const onNavbarLeftClick = () => {
  // 配置跳转方式
  store.commit('app/changeRouterType', 'back')
  router.back()
}

/**
 * 移动端：退出登录
 */
const onLogoutClick = () => {
  confirm('确定要退出登录吗？').then(() => {
    store.dispatch('user/logout')
  })
}
</script>

<style lang="scss" scoped></style>
```

### 15.12 头像裁剪构建方案

想要处理图片裁剪我么需要使用到 **[cropperjs](https://github.com/fengyuanchen/cropperjs)**，网站地址：https://fengyuanchen.github.io/cropperjs/。 他是一个 JavaScript 的库，同时支持 PC 端 和 移动端

目前 `cropperjs` 的最新发布版本是 1.5.12， `V2` 级别版本还是 alpha 阶段，所以我们还是使用它的 V1 版本

1. 安装` cropperjs`

   ```bash
   npm install cropperjs@1.5.12 --save
   ```

2. 在 `src\views\profile\components\change-avatar.vue` 中进行导入

   ```js
   import Cropper from 'cropperjs'
   import 'cropperjs/dist/cropper.css'
   ```

3. 使用 new Cropper 进行初始化，区分 PC端 和 移动端：所有配置项

   ```js
   // 移动端配置对象
   const mobileOptions = {
     // 将裁剪框限制在画布的大小
     viewMode: 1,
     // 移动画布，裁剪框不动
     dragMode: 'move',
     // 裁剪框固定纵横比：1:1
     aspectRatio: 1,
     // 裁剪框不可移动
     cropBoxMovable: false,
     // 不可调整裁剪框大小
     cropBoxResizable: false
   }
   
   // PC 端配置对象
   const pcOptions = {
     // 裁剪框固定纵横比：1:1
     aspectRatio: 1
   }
   ```


### 15.13 阿里云OSS与腾讯云COS对象存储方案分析

当图片裁剪完成之后，接下来就可以处理裁剪之后的图片上传了。

在企业开发中，图片或者文件的管理都会通过 对象存储 的方案进行，目前国内常见的对象存储云方案主要有两个平台：

1. **阿里云OSS**
2. **[腾讯云COS](https://cloud.tencent.com/act/pro/free)**

**腾讯云COS**

腾讯云 COS 目前提供了 实名认证赠送6个月对象存储服务，点击跳转

COS SDK（COS的包）

对应文档地址

1. 下载依赖包：

   ```bash
   npm install -save cos-js-sdk-v5
   ```

**阿里云 OSS**(使用多) 推荐

### 15.14 使用临时凭证，上传裁剪图片到阿里云OSS

具体步骤如下：

1. 安装 ali-oss 依赖
2. 通过接口获取临时的访问凭证，生成OSS实例
3. 利用 ossClient.put 方法，完成对应上传

安装步骤：

1. 安装 `ali-oss` 依赖

```bash
npm install --save ali-oss@6.17.0
```

2. 创建 `src/utils/sts.js` 模块，用来生成 `OSS` 实例

   ```js
   import OSS from 'ali-oss'
   import { REGION, BUCKET } from '@/constants'
   import { getSts } from '@/api/sys'
   
   export const getOSSClient = async () => {
     const res = await getSts()
     return new OSS({
       // yourRegion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。
       region: REGION,
       // 从STS服务获取的临时访问密钥（AccessKey ID和AccessKey Secret）。
       accessKeyId: res.Credentials.AccessKeyId,
       accessKeySecret: res.Credentials.AccessKeySecret,
       // 从STS服务获取的安全令牌（SecurityToken）。
       stsToken: res.Credentials.SecurityToken,
       // 填写Bucket名称。
       bucket: BUCKET,
       // 刷新 token，在 token 过期后自动调用（但是并不生效，可能会在后续的版本中修复）
       refreshSTSToken: async () => {
         // 向您搭建的STS服务获取临时访问凭证。
         const res = await getSts()
         return {
           accessKeyId: res.Credentials.AccessKeyId,
           accessKeySecret: res.Credentials.AccessKeySecret,
           stsToken: res.Credentials.SecurityToken
         }
       },
       // 刷新临时访问凭证的时间间隔，单位为毫秒。
       refreshSTSTokenInterval: 5 * 1000
     })
   }
   ```


### 15.15 完成头像更新操作

`src\views\profile\components\change-avatar.vue`

```js
/**
 * 进行 OSS 上传
 */
let ossClient = null
let store = useStore()
const putObjectToOSS = async (file) => {
  if (!ossClient) {
    ossClient = await getOSSClient()
  }
  try {
    // 因为当前凭证只具备 images 文件夹下的访问权限，所以图片需要上传到 images/xxx.xx 。否则你将得到一个 《AccessDeniedError: You have no right to access this object because of bucket acl.》 的错误
    const fileTypeArr = file.type.split('/')
    const fileName = `${store.getters.userInfo.username}/${Date.now()}.${
      fileTypeArr[fileTypeArr.length - 1]
    }`
    // 文件存放路径，文件
    const res = await ossClient.put(`images/${fileName}`, file)
    // 通知服务器
    onChangeProfile(res.url)
  } catch (e) {
    message('error', e)
  }
}

/**
 * 上传新头像到服务器
 */
const onChangeProfile = async (avatar) => {
  // 更新本地数据
  store.commit('user/setUserInfo', {
    ...store.getters.userInfo,
    avatar
  })
  // 更新服务器数据
  await putProfile(store.getters.userInfo)
  // 通知用户
  message('success', '用户头像修改成功')
  // 关闭 loading
  loading.value = false
  // 关闭 dialog
  close()
}

/**
 * 关闭事件
 */
const close = () => {
  emits(EMITS_CLOSE)
}
```

### 15.16 登录鉴权解决方案

权限处理逻辑：`src\permission.js`

```js
import router from '@/router'
import store from '@/store'
import { message } from '@/libs'

/**
 * 处理需登录页面的访问权限
 * vue-router 全局前置守卫
 */
router.beforeEach((to, from) => {
  // 无需登录的页面访问
  // 返回 false 以取消导航
  if (!to.meta.user) {
    return
  }
  // 已登录，可进入
  if (store.getters.token) {
    return true
  }

  // 未登录，警告然后返回首页
  message('warn', '登录失效，请重新登录!')
  return '/'
})
```

主程序导入登录鉴权：`src\main.js`

```js
...
import router from './router'
import store from './store'
import mLibs from './libs'
...
import './permission'
...
```



## 16 移动端路由切换解决方案 -- 虚拟任务栈让你的H5像APP一样丝滑

### 16.2 通用组件：trigger-menu 和 trigger-item 构建方案分析

1. trigger-menu：只起到一个 **包裹容器** 的作用，所以我们只需要提供一个对应的插槽即可
2. trigger-menu-item： 起到了对应的展示作用，展示包括了 icon 和 文字。所以内部应该存在`svg-icon`用来展示图片，存在一个插槽用来展示文字。

### 16.3 通用组件：构建trigger-menu 和 trigger-item

`trigger-menu` ：`src\libs\trigger-menu\index.vue`

```vue
<template>
  <div
    class="min-w-[180px] bg-white dark:bg-zinc-800 rounded-full shadow flex items-center justify-between px-2 py-1"
  >
    <slot />
  </div>
</template>

<script setup></script>
```

`trigger-menu-item`：`src\libs\trigger-menu-item\index.vue`

```vue
<template>
  <div
    class="w-5 flex flex-col items-center justify-center col mx-0.5"
    @click="onItemClick"
  >
    <m-svg-icon
      :name="icon"
      :fillClass="iconClass"
      class="w-2 h-2"
    ></m-svg-icon>
    <p class="text-sm mt-0.5" :class="textClass">
      <slot />
    </p>
  </div>
</template>

<script setup>
import { useRouter } from 'vue-router'

const props = defineProps({
  // 图标 icon 名字
  icon: {
    type: String,
    required: true
  },
  // 图标样式
  iconClass: {
    type: String
  },
  // 文字样式
  textClass: {
    type: String,
    default: 'text-zinc-900 dark:text-zinc-200'
  },
  // 跳转地址
  to: {
    type: String
  }
})

const router = useRouter()
const onItemClick = () => {
  if (!props.to) {
    return
  }
  router.push(props.to)
}
</script>

<style lang="scss" scoped></style>
```

引用：`src\views\main\index.vue`

```vue
...
<m-trigger-menu
      v-if="isMobileTerminal"
      class="fixed bottom-6 m-auto left-0 right-0 w-[220px]"
    >
      <m-trigger-menu-item
        icon="home"
        iconClass="fill-zinc-900 dark:fill-zinc-200"
      >
        首页
      </m-trigger-menu-item>
      <m-trigger-menu-item
        v-if="$store.getters.token"
        icon="vip"
        iconClass="fill-zinc-400 dark:fill-zinc-500"
        textClass="text-zinc-400 dark:text-zinc-500"
        @click="onVipClick"
      >
        VIP
      </m-trigger-menu-item>
      <m-trigger-menu-item
        icon="profile"
        iconClass="fill-zinc-400 dark:fill-zinc-500"
        textClass="text-zinc-400 dark:text-zinc-500"
        @click="onMyClick"
      >
        {{ $store.getters.token ? '我的' : '登录' }}
      </m-trigger-menu-item>
    </m-trigger-menu>
...
```

### 16.4 前台业务下H5的应用场景

通常情况下我们说起移动端项目，指的一般是两种：

1. 原生 APP
2. H5 网页

此时我们所指的移动端就是 `H5` 网页

该内容依然是以网页为主，但是被运行到手机端之中

而 `H5` 网页应用到手机端的时候，通常也是有**两种运行**的形式:

1. 直接在手机端浏览器中运行:这种使用情况相对较少。在这种情况下，用户明显的知道这就是一个网页。
2. 在原生组件 `WebView` 中运行(混合开发):通常会被嵌入到 `APP` 之中，这种使用情况比较多。所以以下内容，主要针对这种情况进行说明。

那么这种情况下，用户会认为该内容是 `APP`的一部分，不会把它当成网页，而是会把它当做 原生`APP` 。那么一旦用户把它作为 `APP` 来进行衡量，那么就会对这块应用有更高的要求。

### 15.5 通用组件：transition-router-view 构建方案分析 与 虚拟任务栈

接下来实现 **移动端的过渡动效**，以达到一个良好的移动端用户交互体验

他的实现方案整体分为两种：

1. 过渡动画
2. 组件缓存

**过渡动画**

在官方组件功能描述中，主要包含了三个对应的组件：

```vue
  <!-- 路由出口 -->
  <router-view v-slot="{ Component }">
    <!-- 动画 -->
    <transition :name="transitionName"> 
      <!-- 动态组件 -->
      <component :is="Component"></component>
    </transition>
  </router-view>
```

1. 进入动画
2. 退出动画

所以这里的`trransition`的 `name` 需要是动态的，一次来表示对应的两种动画形式。

**组件缓存**

同时因为我们要使用到 **组件缓存**， 所以我们还需要依赖 keep-alive

那么这四个组件想要在一起工作，将要按照以下的方式进行组合

```vue
  <!-- 路由出口 -->
  <router-view v-slot="{ Component }">
    <!-- 动画组件 -->
    <transition :name="transitionName">
      <!-- 缓存组件 -->
      <keep-alive>
        <!-- 动态组件 -->
        <component 
             :is="Component" 
             :key="$route.fullPath" />   <!-- 同域名下的跳转，比如（动态路由 /detail/:id） -->
      </keep-alive>
    </transition>
  </router-view>
```

但是同样有一点，大家需要注意：**不是所有的组件都需要缓存**

我们把：**组件的进入和退出流程，比作一个栈。**

那么只有进入到栈中的组件才需要被缓存，这就像 **Android** 中的 **任务栈** 概念一样。

在当前咱们移动端的组件处理中，我们同样期望有一个这样的栈来维护我们的组件进入和退出流程，所以我们把这样的套流程，称作:**虚拟任务栈**

那么对于这样的一个虚拟任务栈而言，我们可以通过 **数组** 来进行维护，因为数组与栈的概念相同都是:**先进后出** 的流
程。

然后我们可以通过 `keep-alive` 中的` include` 概念，把 虚**拟任务栈·数组** 进行绑定，从而实现 **任务栈** 的缓存概念。

**总结：**

1. 过渡动画：利用 **过渡动效** 实现
2. 组件缓存： 虚拟任务栈 - 数组 配合 keep-alive 中的 include 实现



### 16.7 通用组件：处理过渡动效展示样式错误的问题

`src\libs\transition-router-view\index.vue`

```vue
<template>
  <!-- 路由出口 -->
  <router-view v-slot="{ Component }">
    <!-- 动画组件 -->
    <transition
      :name="transitionName"
      @before-enter="beforeEnter"
      @after-leave="afterLeave"
    >
      <!-- 缓存组件 -->
      <keep-alive :include="virtualTaskStack">
        <component
          :is="Component"
          :class="{ 'fixed top-0 left-0 w-screen z-50': isAnimation }"
          :key="$route.fullPath"
        />
      </keep-alive>
    </transition>
  </router-view>
</template>

<script>
import { ref } from 'vue'
import { useRouter } from 'vue-router'

// 无需监听路由的各种状态（在 PC 端下）
const NONE = 'none'
// 路由进入
const PUSH = 'push'
// 路由退出
const BACK = 'back'
// 路由跳转的 enum
const ROUTER_TYPE_ENUM = [NONE, PUSH, BACK]
</script>

<script setup>
const props = defineProps({
  // 路由跳转的类型，对应 ROUTER_TYPE_ENUM
  routerType: {
    type: String,
    default: NONE,
    validator(val) {
      const result = ROUTER_TYPE_ENUM.includes(val)
      if (!result) {
        throw new Error(
          `你的 routerType 必须是 ${ROUTER_TYPE_ENUM.join('、')} 中的一个`
        )
      }
      return result
    }
  },
  // 首页的组件名称，对应任务栈中的第一个组件
  mainComponentName: {
    type: String,
    required: true
  }
})

// 任务栈
const virtualTaskStack = ref([props.mainComponentName])

const router = useRouter()
// 跳转动画
const transitionName = ref('')
/**
 * 监听路由变化
 */
router.beforeEach((to, from) => {
  // 定义当前动画名称
  transitionName.value = props.routerType

  if (props.routerType === PUSH) {
    // 入栈
    virtualTaskStack.value.push(to.name)
  } else if (props.routerType === BACK) {
    // 出栈
    virtualTaskStack.value.pop()
  }

  // 进入首页默认清空栈
  if (to.name === props.mainComponentName) {
    clearTask()
  }
})

// 处理动画状态变化
const isAnimation = ref(false)
const beforeEnter = () => {
  isAnimation.value = true
}
const afterLeave = () => {
  isAnimation.value = false
}

/**
 * 清空栈
 */
const clearTask = () => {
  virtualTaskStack.value = [props.mainComponentName]
}
</script>

<style lang="scss" scoped>
// push页面时：新页面的进入动画
.push-enter-active {
  animation-name: push-in;
  animation-duration: 0.4s;
}
// push页面时：老页面的退出动画
.push-leave-active {
  animation-name: push-out;
  animation-duration: 0.4s;
}
// push页面时：新页面的进入动画
@keyframes push-in {
  0% {
    transform: translate(100%, 0);
  }
  100% {
    transform: translate(0, 0);
  }
}
// push页面时：老页面的退出动画
@keyframes push-out {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(-50%, 0);
  }
}

// 后退页面时：即将展示的页面动画
.back-enter-active {
  animation-name: back-in;
  animation-duration: 0.4s;
}
// 后退页面时：后退的页面执行的动画
.back-leave-active {
  animation-name: back-out;
  animation-duration: 0.4s;
}
// 后退页面时：即将展示的页面动画
@keyframes back-in {
  0% {
    width: 100%;
    transform: translate(-100%, 0);
  }
  100% {
    width: 100%;
    transform: translate(0, 0);
  }
}
// 后退页面时：后退的页面执行的动画
@keyframes back-out {
  0% {
    width: 100%;
    transform: translate(0, 0);
  }
  100% {
    width: 100%;
    transform: translate(50%, 0);
  }
}
</style>
```

### 16.8 通用组件：虚拟任务栈处理

移动端路由表需要增加 name 字段

每个组件 index.vue 都要导出 name ：组建的名字，才能被缓存

```js
<script>
export default {
  name: 'home'
}
</script>
```

组件缓存逻辑

```vue
<template>
  <!-- 路由出口 -->
  <router-view v-slot="{ Component }">
    <!-- 动画组件 -->
    <transition
      :name="transitionName"
      @before-enter="beforeEnter"
      @after-leave="afterLeave"
    >
      <!-- 缓存组件 -->
      <keep-alive :include="virtualTaskStack">
        <component
          :is="Component"
          :class="{ 'fixed top-0 left-0 w-screen z-50': isAnimation }"
          :key="$route.fullPath"
        />
      </keep-alive>
    </transition>
  </router-view>
</template>
```

动态路由，从一个详情跳转到另外一个详情页面，对应的是一个组件 一个 name 

`src\router\modules\pc-routes.js`

```js
...
{
   path: '/pins/:id',
   name: 'pins',
   component: () => import('@/views/pins/index.vue')
},
...
```

此时缓存有问题，跳转也会有问题

解决方法：给component 添加 key，之前是放在 router-view 上的

```vue
<component
    :is="Component"
    :class="{ 'fixed top-0 left-0 w-screen z-50': isAnimation }"
    :key="$route.fullPath"
 />
```

### 16.9 通用组件：记录页面滚动位置

keep-alive 组件只能够帮助我们缓存组件，但是不能够记录页面的滚动位置

所以如果我们想要记录页面滚动位置的话，需要在 **通用组件外** 单独处理。

目前在当前应用中我们仅需要保存 home 页面的滚动位置即可:

1. 在 `src/views/main/index.vue` 中，进行记录滚动位置，可以通过 [**`useScroll`**](https://vueuse.nodejs.cn/core/useScroll/#directive-usage) 进行记录

   ```vue
   <template>
     <div
       class="h-full overflow-auto bg-white dark:bg-zinc-800 duration-500 scrollbar-thin scrollbar-thumb-transparent xl:scrollbar-thumb-zinc-200 xl:dark:scrollbar-thumb-zinc-900 scrollbar-track-transparent"
       ref="containerTarget"
     >
       <navigation-vue></navigation-vue>
         ...
         ...
   <template>
   <script>
   export default {
     name: 'home'
   }
   </script>
   
   <script setup>
   /**
    * 记录页面滚动位置
    */
   const containerTarget = ref(null)
   const { y: containerTargetScrollY } = useScroll(containerTarget)
   // 被缓存的组件再次可见，会回调 onActivated 方法
   onActivated(() => {
     if (!containerTarget.value) {
       return
     }
     containerTarget.value.scrollTop = containerTargetScrollY.value
   })
   </script>
   ```

### 16.10 总结

那么到这里咱们的整个移动端路由切换就已经全部完成了，本章主要涉及到了两个通用组件的构建:
1. trigger-menu && trigger-menu-item
2. transition-router-view :
  1. 动画效果
  2. 组件缓存
  3. 滚动位置缓存

那么对于咱们的整个应用而言，页面部分就只剩 VIP服务页面了，那么下一章我们就去处理这个最后的页面。

## 17 VIP通用业务构建方案

到现在为止，我们还剩下最后一个 升级 VIP的页面，定义 VIP 的核心是 **支付**，剩下的所有逻辑都是为了最终的 支付来服务的。

但是支付属于第三方服务，我们会在后面进行统一讲解，所以本章不会涉及到支付业务，而是仅在支付前的业务模型中进行处理。

那么本章中所设计到的主要内容包含两部分:

1. 基础的业务构建
2. 优惠倒计时通用组件

那么明确好了本章的内容之后，就让我们开始本章的内容。

### 17.2 构建基础样式

### 17.3 通用组件：倒计时构建方案分析

特惠部分存在一个倒计时的功能，所以我们需要先处理对应的倒计时模块，并把它处理成一个通用组件。

那么对于倒计时模块我们又应该如何进行处理呢?

所谓倒计时，其实更多的是一个时间的处理，那么对于时间的处理，

此时我们就需要使用到一个第三方的包过这个包：[**`dayjs`**](https://day.js.org/zh-CN/)

我们可以处理对应的倒计时格式问题。

那么时间格式处理完成之后，接下来我们就需要处理对应的数据

我们期望对倒计时模块，可以传递两个值:

1. `time`毫秒值:表示倒计时的时长
2. format 格式:表示倒计时的展示格式

那么到这里咱们整个的倒计时功能即使就分析的差不多了，总共分成了两部分:

1. 时间格式
2. 数据

### 17.4 通用组件：倒计时构建方案

`src\libs\count-down\index.vue`

```vue
<template>
  <div>
    <slot>
      <p class="text-sm">
        {{ showTime }}
      </p>
    </slot>
  </div>
</template>

<script>
const INTERVAL_COUNT = 1000
// 倒计时结束
const EMITS_FINISH = 'finish'
// 倒计时改变
const EMITS_CHANGE = 'change'
</script>

<script setup>
import { onUnmounted } from '@vue/runtime-core'
import { computed, watch, ref } from 'vue'
import dayjs from './utils'

const emits = defineEmits([EMITS_FINISH, EMITS_CHANGE])

const props = defineProps({
  // 毫秒
  time: {
    type: Number,
    required: true
  },
  // 遵循 dayjs format 标准：https://day.js.org/docs/zh-CN/parse/string-format
  format: {
    type: String,
    default: 'HH:mm:ss'
  }
})

/**
 * 开始倒计时
 */
const start = () => {
  close()
  interval = setInterval(() => {
    durationFn()
  }, INTERVAL_COUNT)
}
// 倒计时时长
const duration = ref(0)
/**
 * 倒计时行为
 */
const durationFn = () => {
  duration.value -= INTERVAL_COUNT
  emits(EMITS_CHANGE)
  // 监听结束行为
  if (duration.value <= 0) {
    duration.value = 0
    emits(EMITS_FINISH)
    close()
  }
}

/**
 * 清理倒计时
 */
let interval = null
const close = () => {
  if (interval) {
    clearInterval(interval)
  }
}

/**
 * 组件销毁时，清理倒计时
 */
onUnmounted(() => {
  close()
})

/**
 * 处理显示时间
 */
const showTime = computed(() => {
  return dayjs.duration(duration.value).format(props.format)
})

/**
 * 开始倒计时
 */
watch(
  () => props.time,
  (val) => {
    duration.value = val
    start()
  },
  {
    immediate: true
  }
)
</script>

<style lang="scss" scoped></style>
```

`src\libs\count-down\utils.js`

```js
import dayjs from 'dayjs'
import 'dayjs/locale/zh-cn'
import duration from 'dayjs/plugin/duration'

// 中文
dayjs.locale('zh')
// duration 插件
dayjs.extend(duration)

export default dayjs
```



## 18 登录通用解决方案-- 第三方登录处理

1. QQ登录
2. 微信登录

### 18.2 第三方平台登录解决方案流程大解析

通常情况下我们所说的第三方登录，多指的是:**通过第三方 APP 进行登录**

那么我们这个第三方的 APP是如何和我们自己的应用进行关联的呢?如果大家不是很清楚，那么本小节将为你解答

想要搞明白这个问题，那么我们首先需要搞清楚整个第三方登录的流程是如何进行的。

我们以慕课网第三方登录为例:

1. 点击第三方登录按钮

2. 弹出一个小窗口，展示对应二维码

3. 手机打开对应的 APP 进行扫码之后，会跳转到 同意页面，同时浏览器端也会显示扫码成功

4. 手机端操作同意登录之后，会出现两种情况:

   1. 当前用户已注册:
      1. 直接登录

   2. 当前用户未注册:
      1. 执行注册功能:填写手机号接收短信

那么在这样的一个流程之中，第三方 APP 和我们自己的应用，分别都做了什么事情呢?

同样，我们对照流程来去进行说明:

1. 点击第三方登录按钮:执行 `window.open` 方法，打开一个第三方指定的 URL 窗口，该地址会指向第三方登录的URL，并且由第三方提供一个对应的 **二维码**

2. 弹出一个小窗口，展示对应二维码:此处展示的二维码，即为上一步中第三方提供的二维码

3. 手机打开对应的 APP进行扫碎之后，会跳转到 **同意页面**、同时浏览器端也会显示扫码成功:在第三方中会一直对该页面进行 **轮询**，配合第三方 APP 来判断是否扫码成功

4. 手机端操作同意登录之后，会出现两种情况:在 APP中同意之后，第三方会进行对应的跳转，跳转地址为你指定的地址，在该地址中可以获取到 **第三方的用户信息**，该信息即为第三方登录时要获取到的关键数据。

5. 至此，第三方操作完成。接下来需要进行本平台的登录判定

   1. 该注册指的是 **第三方用户** 是否在本平台中进行了注册。

   2. 因为在之前的所有操作中，我们拿到的是 **第三方的用户信息**

   3. 该信息可以帮助我们直接显示对用的用户名(nickname)和头像，但是因为不包含关键信息(手机号、用户名、密码)所以我们无法使用该信息帮助用户直接登录

   4. 所以我们需要判断当前用户是否在咱们自己的平台中完成了注册

      1. 当前用户已注册:
         1. 直接登录

      2. 当前用户未注册:
         1. 执行注册功能:填写手机号接收短信

共分为两大步骤：

1. 对接第三方平台，获取第三方平台的用户信息
2. 利用该用户信息，完成本应用的注册

### 18.3 QQ开放平台流程大解析

想要对接 QQ登录，那么需要在开发这平台注册：[**QQ互联**](https://connect.qq.com/)

1. 注册账户
2. 认证开发者
3. 注册应用

整体流程如下：

#### 注册账户

1. 点击登录按钮，经行扫码登录
2. 扫码登录

#### 进行开发者审核

1. 点击顶部头像，进入开发者审核阶段
2. 开发者审核分为：公司接入和个人接入
3. 信息输入完成之后，点击下一步进行邮箱验证
4. 进入邮箱访问链接
5. 点击 管理中心，此时账户应处于 个人开发者，审核状态
6. 等待审核通过

#### 创建网站应用（需要等待审核通过之后）

1. 选择 **网站应用**，点击 **创建应用**
2. 选择创建网站应用
3. 填写网站资料
4. 应用创建成功
5. 完善资料，填写网站信息
   1. **会掉地址常见问题及修改方法**

6. 应用创建成功，点击 **应用管理**  可进入应用管理后台
7. 此时应用状态应该为 **审核中**
8. 点击查看按钮，选择 应用接口
9. 此时 登录功能，应该为 **已获取** 状态
10. 点击 **get_user_info** 即可进入 **`API文档`**

那么此时，应用创建成功后，即可进入qq登录对接

### 18.4 QQ登录对接流程：获取QQ用户信息

1. 展示 `QQ `登录二维码
2. 获取用户信息
3. 完成跨页面数据传输
4. 认证是否已注册
5. 完成 `QQ` 对接

#### 展示 `QQ `登录二维码

1. 在 `index.html` 中， 导入固定的 `QQ SDK`

```html
<!-- QQ 登录 -->
<script type="text/javascript" charset="utf-8" src="https://connect.qq.com/qc_jssdk.js" 
        data-appid="101998494" // 你的 apppid
        data-redirecturi="https://imooc-front.lgdsunday.club/login"> // 你配置的登陆成功之后的回调
</script>
```

2. qq登录通用组件：`src\views\login-register\login\qq-login.vue`

   ```vue
   <template>
     <div>
       <span id="qqLoginBtn" v-show="false"></span>
       <m-svg-icon
         class="w-4 cursor-pointer"
         name="qq"
         @click="onQQLogin"
       ></m-svg-icon>
     </div>
   </template>
   
   <script>
   // QQ 登录的 URL
   const QQ_LOGIN_URL =
     'https://graph.qq.com/oauth2.0/authorize?client_id=101998494&response_type=token&scope=all&redirect_uri=https%3A%2F%2Fimooc-front.lgdsunday.club%2Flogin'
   </script>
   
   <script setup>
   import { onMounted } from 'vue'
   import brodacast from './brodacast'
   import { oauthLogin } from './oauth'
   import { LOGIN_TYPE_QQ } from '@/constants'
   
   // QQ 登录挂起
   // QC 是qq sdk 导入之后注册的全局对象
   onMounted(() => {
     QC.Login(
       {
         btnId: 'qqLoginBtn' //插入按钮的节点id
       },
       // 登录成功之后的回调，但是需要注意，这个回调只会在《登录回调页面中被执行》
       // 登录存在缓存，登录成功一次之后，下次进入页面会自动重新登录（即：触发该方法，所以我们应该在离开登录页面时，注销登录）
       (data, opts) => {
         console.log('QQ登录成功')
         // 1. 注销登录，否则在后续登录中会直接触发该回调，防止下一次打开页面直接展示上一次的用户信息
         QC.Login.signOut()
         // 2. 获取当前用户唯一标识，作为判断用户是否在我们的应用中已注册的依据
         const accessToken = /access_token=((.*))&expires_in/.exec(
           window.location.hash
         )[1]
         // 3. 拼接请求对象，数据目前是在展开的回调小窗口里面，需要传输我们的当前应用里面
         const oauthObj = {
           nickname: data.nickname,
           figureurl_qq_2: data.figureurl_qq_2,
           accessToken
         }
         // 4. 完成跨页面传输
         brodacast.send(oauthObj)
   
         // 针对于 移动端而言：通过移动端触发 QQ 登录会展示三个页面，原页面、QQ 吊起页面、回调页面。并且移动端一个页面展示整屏内容，且无法直接通过 window.close() 关闭，所以在移动端中，我们需要在当前页面继续进行后续操作。
         oauthLogin(LOGIN_TYPE_QQ, oauthObj)
         // 5. 在 PC 端下，关闭第三方窗口
         window.close()
       }
     )
   })
   
   /**
    * 登录按钮事件
    */
   const onQQLogin = () => {
     openQQWindow()
   }
   
   /**
    * 处理 QQ 登录视窗
    */
   const openQQWindow = async () => {
     window.open(
       QQ_LOGIN_URL,
       'oauth2Login_10609',
       'height=525,width=585, toolbar=no, menubar=no, scrollbars=no, status=no, location=yes, resizable=yes'
     )
     // 打开视窗之后开始等待
     brodacast.wait().then(async (oauthObj) => {
       // 登录成功,关闭通知
       brodacast.clear()
       // 执行登录操作
       oauthLogin(LOGIN_TYPE_QQ, oauthObj)
     })
   }
   </script>
   ```

   **注意**：此时代码登录之后，进入的地址为 **线上的回调地址**，所以后续的调式我们必须在线上进行。

   **上传当前的代码到线上测试环境，进行下一步调试**，具体发布流程请查看：发布处理方案--前台项目构建与发布处理

   如果没有线上服务器，后续操作可以先不去完成，等待实际工作中需要对接时，再去进行查看。

### 18.5 QQ登录对接流程：跨页面信息传输（*********）

想要实现跨页面信息传输，通常有两种不同方式：

1. [**`BroadcastChannel`**](https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel)：允许 **同源**的不同浏览器窗口，Tab页，`frame`或者`iframe`下的不同文档之间相互通信。但是会存在兼容性问题，实测`Safari@15.3`无法使用

2. **`localStorage` + `window.onstorage`**：通过 `localStorage` 进行 同源 的数据传输，用来处理 `BroadcastChannel` 不兼容的浏览器.

   创建 `broadcast.js` 模块：`src\views\login-register\login\brodacast.js`

   ```js
   // 频道名 关键的 key 值，自定义的
   const LOGIN_SUCCESS_CHANNEL = 'LOGIN_SUCCESS_CHANNEL'
   
   // 官方声明 safari 支持 BroadcastChannel ，但是实测 15.3 的版本并不支持 😠，所以我们需要对其进行判定使用，在不支持 BroadcastChannel 的浏览器中，使用 localstorage
   let broadcastChannel = null
   if (window.BroadcastChannel) {
     broadcastChannel = new BroadcastChannel(LOGIN_SUCCESS_CHANNEL)
   }
   
   /**
    * 等待 QQ 登录成功
    * 因为 QQ 登录会在一个新的窗口中进行，用户扫码登录成功之后会回调《新窗口的 QC.Login 第二参数 cb》，而不会回调到原页面。
    * 所以我们需要在《新窗口中通知到原页面》，所以就需要涉及到 JS 的跨页面通讯，而跨页面通讯指的主要就是《同源页面的通讯》
    * 同源页面的通讯方式有很多，我们这里主要介绍：
    * 1. BroadcastChannel  ->  https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel
    * 2. window.onstorage：注意：该事件不在导致数据变化的当前页面触发
    */
   /**
    * 等待回调，它将返回一个 promise，并携带对应的数据
    */
   const wait = () => {
     return new Promise((resolve, reject) => {
       if (broadcastChannel) {
         // 触发 message 事件时的回调函数
         broadcastChannel.onmessage = async (event) => {
           // 改变 promise 状态
           resolve(event.data)
         }
       } else {
         // 触发 localStorage 的 setItem 事件时回调函数
         window.onstorage = (e) => {
           // 判断当前的事件名
           if (e.key === LOGIN_SUCCESS_CHANNEL) {
             // 改变 promise 状态
             resolve(JSON.parse(e.newValue))
           }
         }
       }
     })
   }
   
   /**
    * 发送消息。
    * broadcastChannel：触发 message
    * localStorage：触发 setItem
    */
   const send = (data) => {
     if (broadcastChannel) {
       broadcastChannel.postMessage(data)
     } else {
       localStorage.setItem(LOGIN_SUCCESS_CHANNEL, JSON.stringify(data))
       // 一旦触发 localStorage.setItem(),window.onstorage() 方法就会被触发
     }
   }
   
   /**
    * 清除
    */
   const clear = () => {
     if (broadcastChannel) {
       broadcastChannel.close()
       broadcastChannel = null
     }
     localStorage.removeItem(LOGIN_SUCCESS_CHANNEL)
   }
   
   export default {
     wait,
     send,
     clear
   }
   ```


### 18.6 QQ登录对接流程：认证是否已注册，完成QQ登录流程

`src\views\login-register\login\oauth.js`

```js
import store from '@/store'
import router from '@/router'
import { message } from '@/libs'
import { LOGIN_TYPE_OAUTH_NO_REGISTER_CODE } from '@/constants'

/**
 * 第三方登录统一处理方法
 * @param {*} oauthType 登录方式
 * @param {*} oauthData 第三方数据
 */
export const oauthLogin = async (oauthType, oauthData) => {
  // 触发登录操作，根据登录操作的返回判断当前用户是否已经注册了
  const code = await store.dispatch('user/login', {
    loginType: oauthType,
    ...oauthData
  })
  // 返回  204 表示当前用户未注册，此时给用户一个提示，走注册页面
  if (code === LOGIN_TYPE_OAUTH_NO_REGISTER_CODE) {
    message('success', `欢迎您 ${oauthData.nickname}，请创建您的账号`, 6000)
    // 进入注册页面，同时携带当前的第三方数据和注册标记
    router.push({
      path: '/register',
      query: {
        reqType: oauthType,
        ...oauthData
      }
    })
    return
  }

  // 否则表示用户已注册，直接进入首页
  router.push('/')
}
```

### 18.7 移动端QQ登录对接：触发吊起操作，完成移动端QQ登录

目前我们的 0Q 登录功能已经可以在 PC 端中正常使用了。

但是如果在移动端中进行访问，大家会发现，出现了一些问题。

出现这个问题的原因是因为:

对于 **移动端而言**:通过移动端触发 QQ 登录会展示三个页面，原页面、QQ 吊起页面、回调页面并且移动端一个页面展示整屏内容，

**且无法直接通过 `window.close()` 关闭**。所以在移动端中，我们需要在当前页面中，继续进行后续操作。

### 18.8 微信开放平台大解析(*********)

搞定了 00 扫码登录之后，接下来我们来处理 **微信扫码** 登录。

那么对于微信扫码登录而言，同样需要进行开放平台的注册，所以本小节，我们将为大家讲解微信开放平台的注册流程。整个讲解将会分为:

1. 微信公众平台与微信开放平台的区别
2. 微信开放平台账户注册
3. 微信开放平台应用注册
4. 开发者资质认证

这四个大部分:

**微信公众平台与微信开放平台的区别**

**微信公众平台**
地址:https://mp.weixin.gg.com/

**作用**:用于管理、开放微信公众号(包括订阅号、服务号、企业号)，相当于微信公众号的后台运营、管理系统。

**微信开放平台**
地址:https://open.weixin.qq.com/

**作用**:主要面对移动应用、网站应用开发者，为其提供微信登录、分享、支付等相关权限和服务

登记主体信息-主体类型说明

1. 主体信息常用的分为: 企业 和 **个人**

2. 其中企业又分为: **企业** 和 **个体工商户**

3. 三者之前的区别如下图所示

   个人小程序：禁止 微信认证、微信支付、附近的小程序、小程序注册上线5个

   个体工商户小程序（注册5个）、企业小程序（50个）：都可以微信认证、微信支付、附近的小程序。

完成认证之后

**微信开放平台应用注册**

1. 账户注册通过之后，可进入 管理中心，选择 网站应用，点击 创建网站应用。

**开发者资质认证**（需要付费300元）

申请开通 **微信登录**，个人的  **微信支付** **开通也无法使用**

### 18.9 对接微信扫码登录

进入 微信登录对接官方文档

整个微信登录流程与 QQ 登录流程略有不同，分为以下几步:

1. 通过 微信登录前置数据获取 接口（1次请求），获取登录数据(比如 APP ID )
2. 根据获取到的数据，拼接得到 open url 地址
3. 打开该地址，展示微信登录二维码
4. 移动端微信扫码确定登录
5. 从当前窗口中解析 window.location.search 得到用户的 code 数据
6. 根据 appId、appSecret、code 通过接口获取用户的 access_token（2次请求）
7. 根据 access_token 获取用户信息（3次请求）
8. 通过用户信息触发 oauthLogin 方法

那么接下来我们就根据以上分析分析对应代码代码逻辑:

那么接下来我们就根据以上分析分析对应的代码逻辑

`src\views\login-register\login\weixin-login.vue`

```vue

```

三次接口：`src\api\sys.js`

```js
/**
 * 微信登录前置数据获取（1次请求）
 */
export const getWXLoginData = () => {
  return request({
    url: '/sys/wxlogin/data'
  })
}

/**
 * 获取微信登录的 access_token（2次请求）
 */
export const getWXLoginToken = (appid, secret, code) => {
  return request({
    url: '/sys/wxlogin/access_token',
    params: {
      appid,
      secret,
      code
    }
  })
}

/**
 * 获取微信登录的 用户数据 （3次请求）
 */
export const getWXLoginUserInfo = (accessToken, openid) => {
  return request({
    url: '/sys/wxlogin/userinfo',
    params: {
      accessToken,
      openid
    }
  })
}
```

### 18.10 总结

那么至此我们完成了 **`QQ 扫码登录`**，**微信扫码登录**、**移动端下的 QQ 主动吊起登录**。但是对于 移动端微信 而言，我们不能在普通的 `H5` 下吊起微信 APP 触发登录。
根据我们本章的内容可以发现，整个的第三方登录逻辑还是比较复杂的，特别是微信的第三方登录步骤更加繁琐。并且我们在调试的时候必须要在线上进行调试(**测试环境**)，所以大家在企业开发时，需要有更大的耐心才可以。

## 19 用户反馈解决方案--兔小巢构建反馈功能

在前台系统中，**用户反馈** 功能也是一个非常常见的需求。

通过反馈功能，我们可以知道当前的应用所存在的一些不足和用户对应的一些诉求。

那么通常情况下，构建用户反馈平台通常有两种方式:

1. 自研反馈平台:数据自主，但是成本较高
2. 第三方反馈平台:数据不自主，但是成本极低

所以通常情况下，除非是一线大厂，否则很多的中小型企业都会通过第三方反馈平台来构建用户反馈系统

那么对于我们本章节而言，则是选择了第二种，通过第三方平台来去构建用户反馈系统。

### 19.2 用户反馈整体实现方案分析

在去进行第三方平台的对接之前，我们首先需要先来了解一下，用户反馈功能在应用中的具体体现是什么。

在前言中我们说到过，所谓用户反馈平台，其本质上就是希望给用户一个可以 **发言** 的地方，并且这个最好可以 交流。
那么综上所述，就是一个类似于 **社区** 的概念。

所以所谓的用户反馈平台，就可以理解为一个类似于**社区**平台的内容

同时根据我们之前所说，我们期望通过第三方平台来实现用户反馈平台

这个第三方平台就是 [**腾讯免小巢**](https://txc.qq.com/) 同时它提供了对应的 [**DEMO**](https://support.qq.com/products/1368) 演示。通过演示的 **DEMO** 可以看出，这就是一个类似于社区的平台概念。

那么明确好了对应的内容之后，下一章我们将基于兔小巢来实现咱们的用户反馈平台。

### 19.3 兔小巢全解析

1. 创建产品
2. 填写信息就成功了
3. 进入管理平台
4. 看到的内容就是管理平台

### 19.4 基于兔小巢实现用户反馈

**WEB 接入**

想要在您的产品中接入兔小巢，首先需要获取该产品的`url`，一般由 https://support.qq.com/product/+ 该产品的 ID组成

产品的 ID 在创建时已经分配给您。每个产品有唯一的ID，可以在 **全部产品** 处查看.

根据您的产品 ID 拼接好接入链接，在手机浏览器中输入该地址，即可前往您的产品反馈页面，因为免小巢页面就是一个 `Web App`。

以下为不带参数的跳转，只需要发送 GET 请求即可实现。

前端实现的方式很多，例如 1.用 a 标签设置 `href` 参数;2.直接设置 `window.location` 等等

`src\constants\index.js`

```js
// 兔小巢反馈地址
export const FEEDBACK_URL = 'https://support.qq.com/product/383681'  // 平台给的反馈地址
```

到图标“立即吐槽”页面 `src\views\layout\components\floating\index.vue`

```vue
<template>
...
<div class="w-[140px] overflow-hidden">
   <div
      class="flex items-center p-1 cursor-pointer rounded hover:bg-zinc-100/60 dark:hover:bg-zinc-800"
      @click="onToFeedback"
     >
          <m-svg-icon
            name="feedback"
            class="w-1.5 h-1.5 mr-1"
            fillClass="fill-zinc-900 dark:fill-zinc-300"
          ></m-svg-icon>
          <span class="text-zinc-800 dark:text-zinc-300 text-sm">立即吐槽</span>
        </div>
      </div>
...
</template>
<script setup>
    ...
    import { FEEDBACK_URL } from '@/constants'
    ...
    
    /**
 * 反馈处理
 */
const onToFeedback = () => {
  window.open(FEEDBACK_URL, '_blank')
}
</script>
```



















