# 中前台前端综合解决方案

1. 基于 `vue3.2`，集合最新发布的 script setup 语法标准
2. 融合了几乎所有常见的`前台`、`中台`业务模型
3. 同时适配`移动端`和`PC端`
4. 总结出几十种对应的解决方案，几十种通用的中台组件
5. 时长`30h`

**项目功能介绍**

后台的项目`千篇一律`，前台的项目`花样百出`

**课程收获**

`大厂标准`的项目架构设计

数十种经典业务模型以及对应的解决方案

十几种中台组件的构建思路以及对应的解决方案

**适应人群**

在校学生

新入职场的开发者

有一定经验的开发者

## 2 全新的项目构建方案

### 2.2 `vite` vs `webpack`

1. **为什么快？**

   `webpack` 打包机制：在开发构建时，默认**会去抓取并构建你的整个应用，然后才能提供服务**，这就导致你的项目中，存在的任何一个错误（哪怕是用户从来都没有进入过的页面中出现的），他依然会影响到你的整个项目构建。**当你的项目越大时，构建的时间就会越长**。

   `vite`打包机制：**`vite`不会一开始就构建你的整个项目**，而是会将应用中的模块区分为**依赖**和**源码(项目代码)**两部分，对于部分，它会根据**路由来拆分**代码模块，只会去构建一开始就必须要构建的内容。同时`vite`以[原生ESM](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)的方式为浏览器提供源码，让浏览器接管了**打包**的部分工作。因为这样一个机制，无论你的项目有多大，他只会构建一开始必须要构建的内容，这就让`vite`在构建时的速度打打提升了。

2. **这种机制会存在问题吗？**

   如果项目中存在 `commonJS`的内容，就无法解析。例如`axios`早期版本就依赖`commonJS`规范。

3. **官方如何解决的这种问题？**

   通过[依赖预构建](https://cn.vitejs.dev/guide/dep-pre-bundling.html)，将`CommonJS`或`UMD`发布的依赖项转换为`ESM`，再重新进行编译。可以理解为**速度对业务的一个妥协**。

### 2.4  为什么选择`vite`

当前 `vit` 版本 2.8.5。已经足够支持**企业级开发**

### 2.5 通过`vite`构架《小慕前端》

`vite`版本2.8.0 、`node`16.13.1、 `npm`8.1.2

`vite`需要node版本>=12.0.0

```json
// package.json
"scripts": {
    "dev": "vite --host"
}
```

## 3 定制化、高可用前台样式处理方案

[**tailwindcss**](https://tailwindcss.com/)解决企业及项目下`css`痛点

每隔6个月，你要学习的前端技术就增加了一倍。

- 统一的变量维护困难

- 大量的ClassName负担
- HTML、CSS分离造成了滚动问题
- 响应式、主题切换实现复杂

### 3.3 安装tailwindcss到你的项目

```js
// tailwind.config.js
module.export = {
    // tailwind应用到那些文件
    content: ['./index.html', './src/**/*.{vue,js}'],
    theme: {
        extend: {}
    },
    plugins: []
}
```

创建src/style/index.scss文件，并写入代码：

```scss
// 导入 tailwind 的基础指令组件
@tailwind base;
@tailwind components;
@tailwind utilities;
```

然后在`src/main.js` 中引入该` index.scss` 。

```js
import './style/index.scss'
```

因为使用了`scss`，需要安装sass解析。执行  `npm i -D sass@1.45.0` 安装 sass

在`src/App.vue` 中为`img`标签增加一个 `class="bg-red-900"`，北京变红则表示成功。

### 3.4 tailwindcss初体验

**tailwind** 官方介绍为**无需离开HTML即可快速构建现代网络**。每一个类名背后都代表一个`css`属性

`tailwindcss`是一个非常富有争议的库，喜欢它的人和讨厌它的人都非常多。

### 3.5 tailwind设计理念和价值体现

1. **设计理念**

   - 原子化`css`：每一个类名所代表都是一个`css`属性（争议的核心）

     整个前端历史，`css`颗粒度设计主要分成4种形式（**颗粒度自上而下逐渐增大，颗粒度越大则约束性越高，可定制性越弱**）

     1. 行内样式：样式全部写入行内，自由度最高，可定制化最强，但是不方便样式的复用，每次都要写完整的样式。
     2. 原子化css：每一个类型都代表了一个css属性。自由度依然很强，可定制化依然很高，也方便复用。但是大量的样式会造成大量的类名。
     3. 传统形式：通过一个或几个具有语义化的 class 来描述一段css属性。封装性强，语义化强，自由度和可定制化性一般。但是大量的html需要大量的语义化class，并且在html和css中需要来回切换、查找。
     4. 组件形式：在组件库中极为常见。封装性极强（不光封装了样式，也封装了功能），语义化强。但是自由度和可定制化性比较差

2. **价值体现**

- **高定制化**

- **高个性化**

- **高交互性**

行内样式：无复用性，不适合！

组件样式：通用组件库，固定风格，不适合！

传统形式：响应式、主题替换等复杂功能实现复杂。

综上所述：原子化`CSS`，最合适

总结：

1. 如果想要实现一个**通用的后台项目**，那么推荐使用**通用组件库**实现。
2. 如果想要实现一个**高定制化、高个性化、高交互性**的前台项目，那么推荐使用`tailwindcs`实现









 